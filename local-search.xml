<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习笔记 - Dijkstra</title>
    <link href="/2024/04/03/xuexibiji-dijkstra/"/>
    <url>/2024/04/03/xuexibiji-dijkstra/</url>
    
    <content type="html"><![CDATA[<p>Dijkstra 算法是一种用于寻找图中两点之间最短路径的算法。它由荷兰计算机科学家艾兹赫尔·戴克斯特拉（Edsger W. Dijkstra）在1956年提出，并于1959年发表。</p><h2 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h2><p>Dijkstra算法适用于带权重的图，包括有向图和无向图。算法的核心思想是贪心法：每次找到距离起点最近的一个未被访问的顶点，然后考察所有由这个顶点引出的边，通过这个顶点更新起点到其他所有顶点的距离。</p><h2 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h2><ol><li>初始化：将所有顶点标记为未访问，设置起点到自身的最短距离为 $0$，到其他所有顶点的最短距离为无穷大。</li><li>选择最小距离的未访问顶点 $u$，访问并标记该顶点。</li><li>更新顶点 $u$ 的邻接顶点的距离。</li><li>重复步骤 <code>2</code> 和 <code>3</code>，直到所有顶点都被访问。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt;&amp; graph, <span class="hljs-type">int</span> src)</span> </span>&#123;<br><span class="hljs-type">int</span> V = graph.<span class="hljs-built_in">size</span>();<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(V, numeric_limits&lt;<span class="hljs-type">int</span>&gt;::max())</span></span>;<br>set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; setds;<br>dist[src] = <span class="hljs-number">0</span>;<br>setds.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, src));<br><span class="hljs-keyword">while</span> (!setds.<span class="hljs-built_in">empty</span>()) &#123;<br>pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; tmp = (setds.<span class="hljs-built_in">begin</span>());<br>setds.<span class="hljs-built_in">erase</span>(setds.<span class="hljs-built_in">begin</span>());<br><span class="hljs-type">int</span> u = tmp.second;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = graph[u].<span class="hljs-built_in">begin</span>(); i != graph[u].<span class="hljs-built_in">end</span>(); ++i) &#123;<br><span class="hljs-type">int</span> v = (i).first;<br><span class="hljs-type">int</span> weight = (i).second;<br><span class="hljs-keyword">if</span> (dist[v] &gt; dist[u] + weight) &#123;<br><span class="hljs-keyword">if</span> (dist[v] != numeric_limits&lt;<span class="hljs-type">int</span>&gt;::<span class="hljs-built_in">max</span>()) &#123;<br>setds.<span class="hljs-built_in">erase</span>(setds.<span class="hljs-built_in">find</span>(<span class="hljs-built_in">make_pair</span>(dist[v], v)));<br>&#125;<br>dist[v] = dist[u] + weight;<br>setds.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">make_pair</span>(dist[v], v));<br>&#125;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;Vertex Distance from Source\n&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; V; ++i) cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;\t\t&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 示例图的邻接表表示</span><br>vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; graph = &#123; &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;&#125;, &#123;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;&#125;, &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;&#125;, &#123;&#123;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;&#125;, &#123;&#125; &#125;;<br><span class="hljs-built_in">Dijkstra</span>(graph, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>Dijkstra算法不能处理图中含有负权边的情况。如果图中含有负权边，可以考虑使用Bellman-Ford算法。</li><li>上述C++实现使用了 <code>set</code> 来寻找当前未访问顶点中距离最小的顶点，这使得算法的时间复杂度为 $O(V^2)$。对于稠密图来说是可接受的，但对于稀疏图，可以使用优先队列（<code>priority_queue</code>）来优化，将时间复杂度降低到 $O((V+E)log_2V)$。</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Dijkstra算法是图论中一个非常基础且重要的算法，适用于解决许多实际问题，如网络路由、地图导航等。掌握其原理和实现于解决许多实际问题，如网络路由、地图导航等。掌握其原理和实现对于学习更高级的图论算法也非常有帮助。</p><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><strong>优化技巧</strong>：在实际应用中，Dijkstra 算法的性能可以通过使用优先队列来大幅度提升。优先队列能够保证每次从队列中取出的都是当前最短距离的顶点，这样可以避免对所有顶点的遍历，从而降低算法的时间复杂度。</li><li><strong>变体</strong>：Dijkstra 算法有许多变体，例如，当需要找到从源点到所有其他顶点的最短路径时，可以稍微修改算法来实现。此外，对于特定类型的图（如非负权重图），Dijkstra 算法尤其有效。</li><li><strong>实际应用</strong>：在实际应用中，如地图软件的路径规划，通常会结合 Dijkstra 算法和其他技术（如A*搜索算法）来提高效率和准确性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CF1950C Clock Conversion</title>
    <link href="/2024/04/03/tijie-CF1950C/"/>
    <url>/2024/04/03/tijie-CF1950C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/rbps6s0g">Luogu</a></p><p>本题是一个简单的时间转换程序，将给定的二十四小时制时间转换为十二小时制时间。</p><p>模拟即可，读取字符串后，提出小时和分钟部分，下标为 $0$ 和 $1$ 的数字组成小时部分，$3$ 和 $4$ 组成分钟部分。</p><p>按照题意，根据小时部分和分钟部分，如果小时部分小于 $12$，则时间为 <code>AM</code>，如果小时部分等于 $0$，则小时部分改为 $12$，小时部分大于 $12$，时间为 <code>PM</code>，小时部分减 $12$ 输出即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> T;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; T;<br><span class="hljs-keyword">while</span> (T--) &#123;<br>string s, ans1 = <span class="hljs-string">&quot;&quot;</span>, ans2 = <span class="hljs-string">&quot;&quot;</span>, ans3 = <span class="hljs-string">&quot;&quot;</span>, ans;<br>cin &gt;&gt; s;<br>ans = s.<span class="hljs-built_in">substr</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><span class="hljs-type">int</span> n;<br>n = (s[<span class="hljs-number">0</span>] - <span class="hljs-string">&#x27;0&#x27;</span>) * <span class="hljs-number">10</span> + (s[<span class="hljs-number">1</span>] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>ans1 += s[<span class="hljs-number">0</span>], ans1 += s[<span class="hljs-number">1</span>], ans1 += ans, ans1 += <span class="hljs-string">&quot; AM&quot;</span>;<br>ans2 += <span class="hljs-string">&quot;12&quot;</span>, ans2 += ans;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">12</span> &gt; <span class="hljs-number">9</span>) &#123;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">12</span> == <span class="hljs-number">10</span>)ans3 += <span class="hljs-string">&quot;10&quot;</span>;<br><span class="hljs-keyword">else</span> ans3 += <span class="hljs-string">&quot;11&quot;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ans3 += <span class="hljs-string">&quot;0&quot;</span>;<br>ans3 += (n % <span class="hljs-number">12</span> + <span class="hljs-string">&#x27;0&#x27;</span>);<br>&#125;<br>ans3 += ans;<br>ans3 += <span class="hljs-string">&quot; PM&quot;</span>;<br>cout &lt;&lt; ((n &lt; <span class="hljs-number">12</span>) ? ((n == <span class="hljs-number">0</span>) ? ans2 + <span class="hljs-string">&quot; AM&quot;</span> : ans1): ((n == <span class="hljs-number">12</span>) ? ans2 + <span class="hljs-string">&quot; PM&quot;</span> : ans3))&lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CF1950B Upscaling</title>
    <link href="/2024/04/03/tijie-CF1950B/"/>
    <url>/2024/04/03/tijie-CF1950B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/5y1bz8oo">Luogu</a></p><p>题目要求根据给定的整数 $n$，输出一个 $2n \times 2n$ 的棋盘，其中每个 $2 \times 2 $的小方块交替使用  <code>#</code> 和 <code>.</code> 构成。</p><p>模拟即可，用一个 <code>flag</code> 表示当前应该使用 <code>#</code> 还是 <code>.</code>，使用两层循环来生成棋盘，每次循环是，先根据 <code>flag</code> 的值输出当前行的两个方块，然后翻转 <code>flag</code> 的值，以便下一行使用相反的符号。  </p><p>每输出完一行，根据 $n$ 的奇偶性来更新 <code>flag</code> 的值，使得下一行的开头与当前行的结尾相反即可，时间复杂度为 $O(n^2)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> T;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n; i += <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * n; j += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (flag)<br>                    cout &lt;&lt; <span class="hljs-string">&quot;##&quot;</span>;<br>                <span class="hljs-keyword">else</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;..&quot;</span>;<br>                flag = !flag;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            <br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span>)<br>                flag = !flag;<br>                <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span> * n; j += <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">if</span> (flag)<br>                    cout &lt;&lt; <span class="hljs-string">&quot;##&quot;</span>;<br>                <span class="hljs-keyword">else</span><br>                    cout &lt;&lt; <span class="hljs-string">&quot;..&quot;</span>;<br>                flag = !flag;<br>            &#125;<br>            cout &lt;&lt; endl;<br><br>            <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                flag = !flag;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - P10293 Troublesome Keys</title>
    <link href="/2024/04/02/tijie-P10293/"/>
    <url>/2024/04/02/tijie-P10293/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/3hqy2zo5">Luogu</a></p><p>如果是正常的键，那么在输入的 s1 和 s2 所统计的个数应该是相同的；<br>如果是愚蠢的键，那么愚蠢的键对应的字母就会在 s1 中比在 s2 中多，而它显示错误的字母就会比 s2 少，那么我们就可以快速的找到显示错误的字母，并且知道按下了多少个愚蠢的键；<br>如果是静音键，那么静音键对应的字母在 s1 中比在 s2 中一定要多。</p><p>但是我们需要我们要遍历两次，因为按下静音键和按下愚蠢的键的次数是可能相同的，需要进行第二次检验。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// n1初始化为- 用于后续的字符替换和删除操作</span><br><span class="hljs-type">char</span> s1, s2, n1 = <span class="hljs-string">&#x27;-&#x27;</span>;<br><br><span class="hljs-comment">// 两个vis数组用于存储字符串a和b中每个字符的出现次数，k用于记录差值</span><br><span class="hljs-type">int</span> vis[<span class="hljs-number">150</span>], vis2[<span class="hljs-number">150</span>], k;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>string a, b;<br>cin &gt;&gt; a &gt;&gt; b;<br><span class="hljs-comment">// 遍历，统计每个字符的出现次数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">length</span>(); i++) &#123;<br>vis[a[i]]++;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b.<span class="hljs-built_in">length</span>(); i++) &#123;<br>vis2[b[i]]++;<br>&#125;<br><br><span class="hljs-comment">// 寻找第一个在b中出现而在a中未出现或出现次数少的字符，记录为s2，并计算差值k</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (vis2[i] &gt; vis[i]) &#123;<br>s2 = (<span class="hljs-type">char</span>)i;<br>k = vis2[i] - vis[i];<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 寻找在a中出现次数比b中多k次且在b中未出现的字符，记录为s1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (vis[i] - vis2[i] == k &amp;&amp; vis2[i] == <span class="hljs-number">0</span>) &#123;<br>s1 = (<span class="hljs-type">char</span>)i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 寻找在a中出现但在b中未出现的字符，且该字符不是s1，记录为n1</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;a&#x27;</span>; i &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; i++) &#123;<br><span class="hljs-keyword">if</span> (vis[i] &gt; vis2[i] &amp;&amp; vis2[i] == <span class="hljs-number">0</span> &amp;&amp; i != s1) &#123;<br>n1 = (<span class="hljs-type">char</span>)i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 根据s1和s2的映射关系以及n1的删除规则，构造新字符串t</span><br>string t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] == s1)t += s2; <span class="hljs-comment">// 如果字符是s1，则替换为s2</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == n1)<span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 如果字符是n1，则跳过，相当于删除操作</span><br><span class="hljs-keyword">else</span> t += a[i]; <span class="hljs-comment">// 其他情况，保持字符不变</span><br>&#125;<br><span class="hljs-comment">// 如果t与b相等，输出s1, s2和n1</span><br><span class="hljs-keyword">if</span> (t == b) &#123;<br>cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br>cout &lt;&lt; n1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 如果第一次构造的字符串t不等于b，则尝试从后向前寻找符合条件的s1和n1，并构造新字符串n2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;z&#x27;</span>; i &gt;= <span class="hljs-string">&#x27;a&#x27;</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (vis[i] - vis2[i] == k &amp;&amp; vis2[i] == <span class="hljs-number">0</span>) &#123;<br>s1 = (<span class="hljs-type">char</span>)i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-string">&#x27;z&#x27;</span>; i &gt;= <span class="hljs-string">&#x27;a&#x27;</span>; i--) &#123;<br><span class="hljs-keyword">if</span> (vis[i] &gt; vis2[i] &amp;&amp; vis2[i] == <span class="hljs-number">0</span> &amp;&amp; i != s1) &#123;<br>n1 = (<span class="hljs-type">char</span>)i;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>string n2;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">length</span>(); i++) &#123;<br><span class="hljs-keyword">if</span> (a[i] == s1)<br>n2 += s2;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a[i] == n1)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">else</span><br>n2 += a[i];<br>&#125;<br><span class="hljs-comment">//这里是剩下为a的情况</span><br>cout &lt;&lt; s1 &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; s2 &lt;&lt; endl;<br>cout &lt;&lt; n1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CCC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WT2024 04 S组备赛 训练作业</title>
    <link href="/2024/04/02/WT202404-homework/"/>
    <url>/2024/04/02/WT202404-homework/</url>
    
    <content type="html"><![CDATA[<h2 id="WT2024-04-S组备赛-Part1"><a href="#WT2024-04-S组备赛-Part1" class="headerlink" title="WT2024 04 S组备赛 Part1"></a><a href="https://www.luogu.com.cn/training/493121">WT2024 04 S组备赛 Part1</a></h2><h3 id="基本图"><a href="#基本图" class="headerlink" title="基本图"></a>基本图</h3><ul><li><a href="https://www.luogu.com.cn/problem/P5318">P5318 【深基18.例3】查找文献</a></li><li><a href="https://www.luogu.com.cn/problem/P2853">P2853 [USACO06DEC] Cow Picnic S</a></li><li><a href="https://www.luogu.com.cn/problem/P1363">P1363 幻象迷宫</a></li><li><a href="https://www.luogu.com.cn/problem/P1347">P1347 排序</a></li><li><a href="https://www.luogu.com.cn/problem/P1127">P1127 词链</a></li></ul><hr><h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><ul><li><a href="https://www.luogu.com.cn/problem/B3647">B3647 【模板】Floyd</a></li><li><a href="https://www.luogu.com.cn/problem/P3371">P3371 【模板】单源最短路径（弱化版）</a></li><li><a href="https://www.luogu.com.cn/problem/P4779">P4779 【模板】单源最短路径（标准版）</a></li><li><a href="https://www.luogu.com.cn/problem/P3385">P3385 【模板】负环</a></li><li><a href="https://www.luogu.com.cn/problem/P6175">P6175 无向图的最小环问题</a></li><li><a href="https://www.luogu.com.cn/problem/P5651">P5651 基础最短路练习题</a></li><li><a href="https://www.luogu.com.cn/problem/P2910">P2910 [USACO08OPEN] Clear And Present Danger S</a></li><li><a href="https://www.luogu.com.cn/problem/P6464">P6464 [传智杯 #2 决赛] 传送门</a></li><li><a href="https://www.luogu.com.cn/problem/P1037">P1037 [NOIP2002 普及组] 产生数</a></li><li><a href="https://www.luogu.com.cn/problem/P2419">P2419 [USACO08JAN] Cow Contest S</a></li><li><a href="https://www.luogu.com.cn/problem/P10110">P10110 [GESP202312 七级] 商品交易</a></li><li><a href="https://www.luogu.com.cn/problem/B3601">B3601 [图论与代数结构 201] 最短路问题_1</a></li><li><a href="https://www.luogu.com.cn/problem/B3602">B3602 [图论与代数结构 202] 最短路问题_2</a></li><li><a href="https://www.luogu.com.cn/problem/P1144">P1144 最短路计数</a></li><li><a href="https://www.luogu.com.cn/problem/P1462">P1462 通往奥格瑞玛的道路</a></li><li><a href="https://www.luogu.com.cn/problem/P1073">P1073 [NOIP2009 提高组] 最优贸易</a></li><li><a href="https://www.luogu.com.cn/problem/P1993">P1993 小 K 的农场</a></li><li><a href="https://www.luogu.com.cn/problem/P1119">P1119 灾后重建</a></li><li><a href="https://www.luogu.com.cn/problem/P2047">P2047 [NOI2007] 社交网络</a></li><li><a href="https://www.luogu.com.cn/problem/P1027">P1027 [NOIP2001 提高组] Car 的旅行路线</a></li><li><a href="https://www.luogu.com.cn/problem/P1078">P1078 [NOIP2012 普及组] 文化之旅</a></li><li><a href="https://www.luogu.com.cn/problem/P5905">P5905 【模板】全源最短路（Johnson）</a></li><li><a href="https://www.luogu.com.cn/problem/P4568">P4568 [JLOI2011] 飞行路线</a></li><li><a href="https://www.luogu.com.cn/problem/P2865">P2865 [USACO06NOV] Roadblocks G</a></li><li><a href="https://www.luogu.com.cn/problem/P1875">P1875 佳佳的魔法药水</a></li><li><a href="https://www.luogu.com.cn/problem/P3403">P3403 跳楼机</a></li><li><a href="https://www.luogu.com.cn/problem/P1099">P1099 [NOIP2007 提高组] 树网的核</a></li><li><a href="https://www.luogu.com.cn/problem/P3008">P3008 [USACO11JAN] Roads and Planes G</a></li><li><a href="https://www.luogu.com.cn/problem/P4366">P4366 [Code+#4] 最短路</a></li><li><a href="https://www.luogu.com.cn/problem/P4467">P4467 [SCOI2007] k短路</a></li><li><a href="https://www.luogu.com.cn/problem/P4042">P4042 [AHOI2014&#x2F;JSOI2014] 骑士游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P2483">P2483 【模板】k 短路 &#x2F; [SDOI2010] 魔法猪学院</a></li></ul><hr><h3 id="最小树"><a href="#最小树" class="headerlink" title="最小树"></a>最小树</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3366">P3366 【模板】最小生成树</a></li><li><a href="https://www.luogu.com.cn/problem/P1194">P1194 买礼物</a></li><li><a href="https://www.luogu.com.cn/problem/P1396">P1396 营救</a></li><li><a href="https://www.luogu.com.cn/problem/P1195">P1195 口袋的天空</a></li><li><a href="https://www.luogu.com.cn/problem/P1550">P1550 [USACO08OCT] Watering Hole G</a></li><li><a href="https://www.luogu.com.cn/problem/P2330">P2330 [SCOI2005] 繁忙的都市</a></li><li><a href="https://www.luogu.com.cn/problem/P2916">P2916 [USACO08NOV] Cheering up the Cow G</a></li><li><a href="https://www.luogu.com.cn/problem/CF1245D">CF1245D Shichikuji and Power Grid</a></li><li><a href="https://www.luogu.com.cn/problem/P4047">P4047 [JSOI2010] 部落划分</a></li><li><a href="https://www.luogu.com.cn/problem/P4180">P4180 [BJWC2010] 严格次小生成树</a></li><li><a href="https://www.luogu.com.cn/problem/P3104">P3104 [USACO14MAR] Counting Friends G</a></li><li><a href="https://www.luogu.com.cn/problem/CF1120D">CF1120D Power Tree</a></li><li><a href="https://www.luogu.com.cn/problem/P3623">P3623 [APIO2008] 免费道路</a></li></ul><h2 id="WT2024-04-S组备赛-Part2"><a href="#WT2024-04-S组备赛-Part2" class="headerlink" title="WT2024 04 S组备赛 Part2"></a><a href="https://www.luogu.com.cn/training/493125">WT2024 04 S组备赛 Part2</a></h2><h3 id="kruskal重构树"><a href="#kruskal重构树" class="headerlink" title="kruskal重构树"></a>kruskal重构树</h3><ul><li><a href="https://www.luogu.com.cn/problem/P9638">P9638 「yyOI R1」youyou 的军训</a></li><li><a href="https://www.luogu.com.cn/problem/P4768">P4768 [NOI2018] 归程</a></li></ul><hr><h3 id="哈希与哈希表"><a href="#哈希与哈希表" class="headerlink" title="哈希与哈希表"></a>哈希与哈希表</h3><ul><li><a href="https://www.luogu.com.cn/problem/P3370">P3370 【模板】字符串哈希</a></li><li><a href="https://www.luogu.com.cn/problem/P1102">P1102 A-B 数对</a></li><li><a href="https://www.luogu.com.cn/problem/P2957">P2957 [USACO09OCT] Barn Echoes G</a></li><li><a href="https://www.luogu.com.cn/problem/P4305">P4305 [JLOI2011] 不重复数字</a></li><li><a href="https://www.luogu.com.cn/problem/P7774">P7774 [COCI2009-2010#2] KUTEVI</a></li><li><a href="https://www.luogu.com.cn/problem/P1211">P1211 [USACO1.3] 牛式 Prime Cryptarithm</a></li><li><a href="https://www.luogu.com.cn/problem/P8630">P8630 [蓝桥杯 2015 国 B] 密文搜索</a></li><li><a href="https://www.luogu.com.cn/problem/P1955">P1955 [NOI2015] 程序自动分析</a></li><li><a href="https://www.luogu.com.cn/problem/P2593">P2593 [ZJOI2006] 超级麻将</a></li><li><a href="https://www.luogu.com.cn/problem/P4398">P4398 [JSOI2008] Blue Mary的战役地图</a></li></ul><hr><h3 id="连通图（强连通分量与割点和桥）"><a href="#连通图（强连通分量与割点和桥）" class="headerlink" title="连通图（强连通分量与割点和桥）"></a>连通图（强连通分量与割点和桥）</h3><ul><li><a href="https://www.luogu.com.cn/problem/P8772">P8772 [蓝桥杯 2022 省 A] 求和</a></li><li><a href="https://www.luogu.com.cn/problem/P2367">P2367 语文成绩</a></li><li><a href="https://www.luogu.com.cn/problem/P6145">P6145 [USACO20FEB] Timeline G</a></li><li><a href="https://www.luogu.com.cn/problem/P1250">P1250 种树</a></li><li><a href="https://www.luogu.com.cn/problem/P5960">P5960 【模板】差分约束</a></li><li><a href="https://www.luogu.com.cn/problem/P1260">P1260 工程规划</a></li><li><a href="https://www.luogu.com.cn/problem/P1993">P1993 小 K 的农场</a></li><li><a href="https://www.luogu.com.cn/problem/P4878">P4878 [USACO05DEC] Layout G</a></li><li><a href="https://www.luogu.com.cn/problem/P3275">P3275 [SCOI2011] 糖果</a></li><li><a href="https://www.luogu.com.cn/problem/P1656">P1656 炸铁路</a></li><li><a href="https://www.luogu.com.cn/problem/P3388">P3388 【模板】割点（割顶）</a></li><li><a href="https://www.luogu.com.cn/problem/P3387">P3387 【模板】缩点</a></li><li><a href="https://www.luogu.com.cn/problem/P8436">P8436 【模板】边双连通分量</a></li><li><a href="https://www.luogu.com.cn/problem/P8435">P8435 【模板】点双连通分量</a></li><li><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN] The Cow Prom S</a></li><li><a href="https://www.luogu.com.cn/problem/P2002">P2002 消息扩散</a></li><li><a href="https://www.luogu.com.cn/problem/CF1000E">CF1000E We Need More Bosses</a></li><li><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL &#x2F; HAOI2006] 受欢迎的牛 G</a></li><li><a href="https://www.luogu.com.cn/problem/P4782">P4782 【模板】2-SAT</a></li><li><a href="https://www.luogu.com.cn/problem/P2746">P2746 [USACO5.3] 校园网Network of Schools</a></li><li><a href="https://www.luogu.com.cn/problem/P2860">P2860 [USACO06JAN] Redundant Paths G</a></li><li><a href="https://www.luogu.com.cn/problem/P3469">P3469 [POI2008] BLO-Blockade</a></li><li><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a></li><li><a href="https://www.luogu.com.cn/problem/P4630">P4630 [APIO2018] 铁人两项</a></li><li><a href="https://www.luogu.com.cn/problem/P4606">P4606 [SDOI2018] 战略游戏</a></li><li><a href="https://www.luogu.com.cn/problem/CF487E">CF487E Tourists</a></li><li><a href="https://www.luogu.com.cn/problem/P5025">P5025 [SNOI2017] 炸弹</a></li><li><a href="https://www.luogu.com.cn/problem/P3825">P3825 [NOI2017] 游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P4819">P4819 [中山市选] 杀人游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P7737">P7737 [NOI2021] 庆典</a></li></ul><hr><h3 id="欧拉回路"><a href="#欧拉回路" class="headerlink" title="欧拉回路"></a>欧拉回路</h3><ul><li><a href="https://www.luogu.com.cn/problem/P7771">P7771 【模板】欧拉路径</a></li><li><a href="https://www.luogu.com.cn/problem/P1341">P1341 无序字母对</a></li><li><a href="https://www.luogu.com.cn/problem/P2731">P2731 [USACO3.3] 骑马修栅栏 Riding the Fences</a></li><li><a href="https://www.luogu.com.cn/problem/P7796">P7796 [COCI2014-2015#7] POLICE</a></li></ul><h2 id="WT2024-04-S组备赛-Part3"><a href="#WT2024-04-S组备赛-Part3" class="headerlink" title="WT2024 04 S组备赛 Part3"></a><a href="https://www.luogu.com.cn/training/493142">WT2024 04 S组备赛 Part3</a></h2><h3 id="树状数组与RMQ"><a href="#树状数组与RMQ" class="headerlink" title="树状数组与RMQ"></a>树状数组与RMQ</h3><ul><li><a href="https://www.luogu.com.cn/problem/P1996">P1996 约瑟夫问题</a></li><li><a href="https://www.luogu.com.cn/problem/P1774">P1774 最接近神的人</a></li><li><a href="https://www.luogu.com.cn/problem/P3374">P3374 【模板】树状数组 1</a></li><li><a href="https://www.luogu.com.cn/problem/P3368">P3368 【模板】树状数组 2</a></li><li><a href="https://www.luogu.com.cn/problem/P1908">P1908 逆序对</a></li><li><a href="https://www.luogu.com.cn/problem/P3948">P3948 数据结构</a></li><li><a href="https://www.luogu.com.cn/problem/P5200">P5200 [USACO19JAN] Sleepy Cow Sorting G</a></li><li><a href="https://www.luogu.com.cn/problem/P5019">P5019 [NOIP2018 提高组] 铺设道路</a></li><li><a href="https://www.luogu.com.cn/problem/P2068">P2068 统计和</a></li><li><a href="https://www.luogu.com.cn/problem/P2880">P2880 [USACO07JAN] Balanced Lineup G</a></li><li><a href="https://www.luogu.com.cn/problem/P4378">P4378 [USACO18OPEN] Out of Sorts S</a></li><li><a href="https://www.luogu.com.cn/problem/P2866">P2866 [USACO06NOV] Bad Hair Day S</a></li><li><a href="https://www.luogu.com.cn/problem/P2251">P2251 质量检测</a></li><li><a href="https://www.luogu.com.cn/problem/P1440">P1440 求m区间内的最小值</a></li><li><a href="https://www.luogu.com.cn/problem/P6225">P6225 [eJOI2019] 异或橙子</a></li><li><a href="https://www.luogu.com.cn/problem/P5094">P5094 [USACO04OPEN] MooFest G 加强版</a></li><li><a href="https://www.luogu.com.cn/problem/P5057">P5057 [CQOI2006] 简单题</a></li><li><a href="https://www.luogu.com.cn/problem/P4939">P4939 Agent2</a></li><li><a href="https://www.luogu.com.cn/problem/P5677">P5677 [GZOI2017] 配对统计</a></li><li><a href="https://www.luogu.com.cn/problem/P1966">P1966 [NOIP2013 提高组] 火柴排队</a></li><li><a href="https://www.luogu.com.cn/problem/P2161">P2161 [SHOI2009] 会场预约</a></li></ul><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><ul><li><a href="https://www.luogu.com.cn/problem/P1816">P1816 忠诚</a></li><li><a href="https://www.luogu.com.cn/problem/P3372">P3372 【模板】线段树 1</a></li><li><a href="https://www.luogu.com.cn/problem/P3870">P3870 [TJOI2009] 开关</a></li><li><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a></li><li><a href="https://www.luogu.com.cn/problem/P1253">P1253 扶苏的问题</a></li><li><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></li><li><a href="https://www.luogu.com.cn/problem/P6492">P6492 [COCI2010-2011#6] STEP</a></li><li><a href="https://www.luogu.com.cn/problem/P1637">P1637 三元上升子序列</a></li><li><a href="https://www.luogu.com.cn/problem/P1558">P1558 色板游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a></li><li><a href="https://www.luogu.com.cn/problem/P1471">P1471 方差</a></li><li><a href="https://www.luogu.com.cn/problem/P5522">P5522 [yLOI2019] 棠梨煎雪</a></li><li><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟 2 &#x2F; 花神游历各国</a></li><li><a href="https://www.luogu.com.cn/problem/P2572">P2572 [SCOI2010] 序列操作</a></li><li><a href="https://www.luogu.com.cn/problem/CF19D">CF19D Points</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>计划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 字典树</title>
    <link href="/2024/03/16/muban-dictree/"/>
    <url>/2024/03/16/muban-dictree/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-comment">//son[][]存储子节点的位置，分支最多26条；</span><br><span class="hljs-comment">//cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span><br><span class="hljs-comment">//idx表示当前要插入的节点是第几个,每创建一个节点值+1</span><br><span class="hljs-type">int</span> son[N][<span class="hljs-number">26</span>], cnt[N], idx;<br><span class="hljs-type">char</span> str[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;  <span class="hljs-comment">//类似指针，指向当前节点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br><span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">//将字母转化为数字</span><br><span class="hljs-keyword">if</span> (!son[p][u]) son[p][u] = ++idx;  <span class="hljs-comment">//该节点不存在，创建节点</span><br>p = son[p][u];  <span class="hljs-comment">//使“p指针”指向下一个节点</span><br>&#125;<br>cnt[p]++;  <span class="hljs-comment">//结束时的标记，也是记录以此节点结束的字符串个数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *str)</span> </span>&#123;<br><span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; str[i]; i++) &#123;<br><span class="hljs-type">int</span> u = str[i] - <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">if</span> (!son[p][u]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//该节点不存在，即该字符串不存在</span><br>p = son[p][u];<br>&#125;<br><span class="hljs-keyword">return</span> cnt[p];  <span class="hljs-comment">//返回字符串出现的次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> m;<br>cin &gt;&gt; m;<br><br><span class="hljs-keyword">while</span> (m--) &#123;<br><span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, op, str);<br><br><span class="hljs-keyword">if</span> (*op == <span class="hljs-string">&#x27;I&#x27;</span>) <span class="hljs-built_in">insert</span>(str);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, <span class="hljs-built_in">query</span>(str));<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 链式前向星</title>
    <link href="/2024/03/16/muban-lianshiqianxiangxing/"/>
    <url>/2024/03/16/muban-lianshiqianxiangxing/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">10000</span>;<br><span class="hljs-comment">// 创建边结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-type">int</span> v, w, next;<br><span class="hljs-comment">// 下一个点，边权，当前边的上一个边</span><br>&#125; edge[MAXN * MAXN];<br><span class="hljs-type">int</span> tot, head[MAXN];<br><br><br><span class="hljs-comment">// 建边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br><span class="hljs-comment">// 建边</span><br>edge[tot].v = v;<br>edge[tot].w = w;<br><span class="hljs-comment">// 连边</span><br>edge[tot].next = head[u];<br>head[u] = tot++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 初始化head</span><br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(head));<br><br><span class="hljs-comment">// 建边</span><br><span class="hljs-type">int</span> t;<br>cin &gt;&gt; t;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t; i++) &#123;<br><span class="hljs-type">int</span> u, v, w;<br>cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br><span class="hljs-built_in">AddEdge</span>(u, v, w);<br>&#125;<br><br><span class="hljs-comment">// 遍历 u 连接的所有边</span><br><span class="hljs-type">int</span> u;<br>cin &gt;&gt; u;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = head[u]; i != <span class="hljs-number">-1</span>; i = edge[i].next) &#123;<br>cout &lt;&lt; edge[i].v &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; edge[i].w &lt;&lt; endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>链表</tag>
      
      <tag>邻接矩阵</tag>
      
      <tag>图</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 邻接表</title>
    <link href="/2024/03/16/muban-linjiebiao/"/>
    <url>/2024/03/16/muban-linjiebiao/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">GraphNode</span>&#123;<br><span class="hljs-type">int</span> label;<br>  vector &lt;GraphNode*&gt; neighbors;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>GraphNode G[<span class="hljs-number">1001</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        G[i].label=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> x,y;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        G[x].neighbors.<span class="hljs-built_in">push_back</span>(&amp;G[y]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;G:\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Label(%d):&quot;</span>,i);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;G[i].neighbors.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,G[i].neighbors[j]-&gt;label);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图</tag>
      
      <tag>邻接表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CF1903C Theofanis&#39; Nightmare</title>
    <link href="/2024/03/16/tijie-CF1903C/"/>
    <url>/2024/03/16/tijie-CF1903C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/zin7q04m">Luogu</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题要求将一个数组分成若干个非空的子数组，然后计算每个子数组的和，并用每个子数组的和乘以子数组的长度，最后求和。问题的关键在于找到一种分割方式，使得其值最大。</p><p>观察发现，我们需要在数组中找到一个位置，将数组分为两个部分，使得右半部分的和尽可能大。对于这个问题，从数组的末尾开始往前遍历是一个比较自然的想法。我们可以维护一个变量 $res$，表示当前遍历到的位置右侧的子数组的和，同时维护一个变量 $sum$，表示值的累加和。每次遍历到一个位置，都更新 $res$，并判断如果 $res$ 大于 $0$ 或者已经遍历到数组的开头，就将 $res$ 累加到 $sum$ 中。最终，$sum$ 即为所求的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br>ll a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin&gt;&gt;t;<br>    <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin&gt;&gt;n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br><br>        ll sum=<span class="hljs-number">0</span>, res=<span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)<br>        &#123;<br>            res += a[i];<br>            <span class="hljs-keyword">if</span>(res &gt; <span class="hljs-number">0</span> || i == <span class="hljs-number">0</span>)<br>                sum += res;<br>        &#125;<br><br>        cout&lt;&lt;sum&lt;&lt;endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - P10134 Cowmpetency</title>
    <link href="/2024/03/16/tijie-P10134/"/>
    <url>/2024/03/16/tijie-P10134/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/n08pvada">Luogu</a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在更新奶牛的牲任力分数序列中：  </p><ul><li>如果某个奶牛的牲任力分数已知，则将其标记为已访问；  </li><li>如果某个奶牛的分数未知，记录其下标，并将其添加到一个集合中。</li></ul><p>然后可以根据记忆信息更新分数：<br>对于每个数对 $(a_j,h_j)$，找到区间内未知分数的奶牛，根据规则更新其分数,同时判断，确保序列满足条件。</p><h3 id="赛时-AC-代码："><a href="#赛时-AC-代码：" class="headerlink" title="赛时 AC 代码："></a>赛时 AC 代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> n, q, c, tp;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> mp[<span class="hljs-number">1000001</span>], mp2[<span class="hljs-number">1000001</span>], mp3[<span class="hljs-number">1000001</span>], isv[<span class="hljs-number">1000001</span>];<br>pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; pairl[<span class="hljs-number">1000001</span>];<br>set&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; setl;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; a, pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> (a.second == b.second) ? (a.first &lt; b.first) : (a.second &lt; b.second);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>setl.<span class="hljs-built_in">clear</span>();<br>cin &gt;&gt; n &gt;&gt; q &gt;&gt; c;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; mp[i];<br><span class="hljs-keyword">if</span> (!mp[i]) &#123;<br>setl.<span class="hljs-built_in">insert</span>(i);<br>isv[i] = <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>isv[i] = <span class="hljs-number">0</span>;<br>&#125;<br>mp3[i] = <span class="hljs-built_in">max</span>(mp3[i - <span class="hljs-number">1</span>], mp[i]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br>cin &gt;&gt; pairl[i].first &gt;&gt; pairl[i].second;<br>&#125;<br><br><span class="hljs-built_in">sort</span>(pairl + <span class="hljs-number">1</span>, pairl + q + <span class="hljs-number">1</span>, cmp);<br>tp = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br><span class="hljs-keyword">if</span> (pairl[i].first &lt; tp &amp;&amp; pairl[i].second != tp) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>tp = pairl[i].second;<br>&#125;<br><br>tp = n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = q; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> a = <span class="hljs-built_in">min</span>(pairl[i].second - <span class="hljs-number">1</span>, tp), b = pairl[i].first + <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> j = a; j &gt;= b; j--) &#123;<br><span class="hljs-keyword">if</span> (!isv[j] &amp;&amp; mp[j] &gt; mp3[pairl[i].first]) &#123;<br>set&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::iterator tp2 = setl.<span class="hljs-built_in">upper_bound</span>(pairl[i].first);<br><span class="hljs-keyword">if</span> (tp2 == setl.<span class="hljs-built_in">begin</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>--tp2;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tp3 = *tp2;<br>mp[tp3] = <span class="hljs-built_in">max</span>(mp[tp3], mp[j]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isv[j] &amp;&amp; mp[j] &gt; mp3[pairl[i].first]) &#123;<br>set&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::iterator tp2 = setl.<span class="hljs-built_in">upper_bound</span>(pairl[i].first);<br><span class="hljs-keyword">if</span> (tp2 == setl.<span class="hljs-built_in">begin</span>()) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>--tp2;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> tp3 = *tp2;<br>mp[tp3] = <span class="hljs-built_in">max</span>(mp[tp3], mp[j]);<br>mp[j] = <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>tp = pairl[i].first;<br>&#125;<br>tp = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= q; i++) &#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> x = pairl[i].second, j;<br>stack&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt; r;<br><span class="hljs-keyword">for</span> (j = i; j &lt;= q &amp;&amp; pairl[j].second == x; j++) &#123;<br>r.<span class="hljs-built_in">push</span>(pairl[j].first);<br>&#125;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> maxn = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">size</span>() &amp;&amp; tp == r.<span class="hljs-built_in">top</span>()) &#123;<br>maxn = <span class="hljs-built_in">max</span>(maxn, mp2[tp]);<br>r.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> k = tp + <span class="hljs-number">1</span>; k &lt;= x - <span class="hljs-number">1</span>; k++) &#123;<br><span class="hljs-keyword">if</span> (!mp[k])<br>mp[k] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (maxn &amp;&amp; mp[k] &gt; maxn) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>mp2[k] = <span class="hljs-built_in">max</span>(mp2[k - <span class="hljs-number">1</span>], mp[k]);<br><span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">size</span>() &amp;&amp; k == r.<span class="hljs-built_in">top</span>()) &#123;<br>maxn = <span class="hljs-built_in">max</span>(maxn, mp2[k]);<br>r.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (isv[x])<br>mp[x] = <span class="hljs-built_in">max</span>(mp[x], maxn + <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (maxn &gt;= mp[x]) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>mp2[x] = <span class="hljs-built_in">max</span>(mp2[x - <span class="hljs-number">1</span>], mp[x]);<br>tp = x;<br>i = j - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = tp + <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (!mp[i])<br>mp[i] = <span class="hljs-number">1</span>;<br>mp2[i] = <span class="hljs-built_in">max</span>(mp2[i - <span class="hljs-number">1</span>], mp[i]);<br>&#125;<br><span class="hljs-keyword">if</span> (mp2[n] &gt; c) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cout &lt;&lt; mp[i];<br><span class="hljs-keyword">if</span> (i != n) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> T;<br>cin &gt;&gt; T;<br><br><span class="hljs-keyword">while</span> (T--) &#123;<br><span class="hljs-built_in">solve</span>();<br>cout&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>USACO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CF1937B Binary Path</title>
    <link href="/2024/03/16/tijie-CF1937B/"/>
    <url>/2024/03/16/tijie-CF1937B/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/article/brtxf2v3">Luogu</a></p><h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>题目要求在一个二维网格中，从左上角出发，只能向右或向下移动，到达右下角的格子。网格中的每个格子包含一个二进制数。经过的路径上的数字按顺序连接成一个二进制字符串。现在要根据题意求解两个问题。</p><p>字典序是指字符串的大小关系，如果两个字符串长度相同，那么在第一个不同的字符处，较小的字符串对应的字符值要小于较大字符串对应的字符值。  </p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>做这道题可以用 dp 求解，当然也可以用贪心，这里只讲 dp 的做法。</p><p>读入后，可以将 $a$ 的第一个字符添加到一个临时字符串中（即初始化路径），同时将 $b$ 中的字符添加到这个灵时字符串的末尾（即模拟移动过程），同时使用一个计数器标记至少有多少条路径。</p><p>接下来，使用一个队列来跟踪临时字符串中的字符是否需要更改，依次检查+判断：  </p><ul><li>如果后面的字符比当前字符大，那么我们已经得到了字典序最小的字符串，此时输出字符串和计数器的值，并结束程序。</li><li>如果后面的字符和当前字符相等，我们增加计数器的值。</li><li>如果后面的字符比当前字符小，我们将当前字符替换为后面的字符，并将需要更改的字符的下标加入队列中。</li></ul><p>遍历队列元素，将队列中下标对应的位置对应的字符替换为 $a$ 中下标相对的的字符，输出即可，输出的即为路径数量。</p><p>同时建议使用 char 读入。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">char</span> a[<span class="hljs-number">200005</span>], b[<span class="hljs-number">200001</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solv</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; a[i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cin &gt;&gt; b[i];<br>&#125;<br>string cur, ans;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>cur += a[<span class="hljs-number">1</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>cur += b[i];<br>&#125;<br>ans = cur;<br>cnt = <span class="hljs-number">1</span>;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">char</span> pre = cur[i], nxt = a[i + <span class="hljs-number">1</span>];<br><span class="hljs-keyword">if</span> (nxt &gt; pre) &#123;<br>cout &lt;&lt; cur &lt;&lt; endl;<br>cout &lt;&lt; cnt &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nxt == pre)<br>cnt++;<br><span class="hljs-keyword">else</span> &#123;<br>cur[i] = nxt;<br>q.<span class="hljs-built_in">push</span>(i);<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>ans[q.<span class="hljs-built_in">front</span>()] = a[q.<span class="hljs-built_in">front</span>() + <span class="hljs-number">1</span>];<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cnt = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>cout &lt;&lt; cnt &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> t;<br>cin &gt;&gt; t;<br><span class="hljs-keyword">while</span> (t--) &#123;<br><span class="hljs-built_in">solv</span>();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
      <category>CF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心</tag>
      
      <tag>模拟</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - LCA (树)</title>
    <link href="/2024/03/11/muban-lca-tree/"/>
    <url>/2024/03/11/muban-lca-tree/</url>
    
    <content type="html"><![CDATA[<h3 id="【题目描述】"><a href="#【题目描述】" class="headerlink" title="【题目描述】"></a>【题目描述】</h3><p>给定n个点的树(1是根)，m次询问，每次询问两点的LCA;</p><h3 id="【输入格式】"><a href="#【输入格式】" class="headerlink" title="【输入格式】"></a>【输入格式】</h3><p>第一行两个整数,n,m;<br>接下来n-1行,给定正整数a,b,表示a,b间有边;<br>接下来m行,给定整数a,b,表示询问a,b;  </p><h3 id="【输出格式】"><a href="#【输出格式】" class="headerlink" title="【输出格式】"></a>【输出格式】</h3><p>对于每个询问,输出它们的LCA;  </p><h3 id="样例数据"><a href="#样例数据" class="headerlink" title="样例数据"></a>样例数据</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br></code></pre></td></tr></table></figure><h3 id="方法1（tarjan“向上标记法”）"><a href="#方法1（tarjan“向上标记法”）" class="headerlink" title="方法1（tarjan“向上标记法”）"></a>方法1（tarjan“向上标记法”）</h3><p>dfs 一条路搜到底时，搜到了起点，在回溯返回时每次将子节点通过倒序合并到父节点上，当搜到终点时，那么 father[起点] 就是起点和终点的转折点LCA。</p><h3 id="方法2（RMQ树上倍增法）"><a href="#方法2（RMQ树上倍增法）" class="headerlink" title="方法2（RMQ树上倍增法）"></a>方法2（RMQ树上倍增法）</h3><p>需要一个数组 $F$，$F[i][j]$ 表示 $i$ 节点之前第 $2^j$ 号祖先。当然，$F[i][0]$ 即是 $i$ 的父节点。<br>$F[i][j]&#x3D;&#x3D;F[F[i][j-1]][j-1]$。<br>那么可以 $O(n log n)$预处理出数组 $F$ </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prepare</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> fence=<span class="hljs-built_in">log</span>(<span class="hljs-number">1.0</span>*(max_dep))/<span class="hljs-built_in">log</span>(<span class="hljs-number">2.0</span>);<br>    p[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=fence;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">if</span>(p[i][j<span class="hljs-number">-1</span>]!=<span class="hljs-number">-1</span>)<br>                p[i][j]=p[p[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>对于每个起点 $a$，终点 $b$。<br>先求出他们的深度数组与 $F$ 数组<br>每次求 LCA 将两个点深度调为一致。然后可以通过一起向上跳的方法求出LCA。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LCA</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">if</span>(dep[b]&gt;dep[a]) <span class="hljs-built_in">swap</span>(a,b);<br>    <span class="hljs-type">int</span> D;<br>    <span class="hljs-keyword">for</span>(D=<span class="hljs-number">0</span>;(<span class="hljs-number">1</span>&lt;&lt;D)&lt;=dep[a];D++);<br>    D--; <span class="hljs-comment">//确定a的最大2次幂深度；</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=D;j&gt;=<span class="hljs-number">0</span>;j--)<br>        <span class="hljs-keyword">if</span>(dep[a]-(<span class="hljs-number">1</span>&lt;&lt;j)&gt;=dep[b])<br>            a=p[a][j]; <span class="hljs-comment">//令a与b深度相同；</span><br>    <span class="hljs-keyword">if</span>(a==b) <span class="hljs-keyword">return</span> a;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=D;j&gt;=<span class="hljs-number">0</span>;j--)<br>        <span class="hljs-keyword">if</span>(p[a][j]!=<span class="hljs-number">-1</span> &amp;&amp; p[a][j]!=p[b][j])<br>            a=p[a][j],b=p[b][j];<br>    <span class="hljs-keyword">return</span> p[a][<span class="hljs-number">0</span>];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>最近公共祖先</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 状态压缩</title>
    <link href="/2024/03/11/muban-zhuangya/"/>
    <url>/2024/03/11/muban-zhuangya/</url>
    
    <content type="html"><![CDATA[<p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/44612da218524149bcb995e06d0b3cbf.png"></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>状态压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题解 - CF1882B Fear of the Dark</title>
    <link href="/2024/03/11/tijie-CF1882B/"/>
    <url>/2024/03/11/tijie-CF1882B/</url>
    
    <content type="html"><![CDATA[<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>利用一个 distance 函数用于计算两点之间的欧几里德距离。</p><p>在主函数中，读取测试用例的数量，处理每个测试用例。<br>对于每个测试用例，计算 $PA$、$PB$、$OA$ 和 $OB$ 的距离。<br>使用条件语句来确定 $w$ 的最小值，最后将结果打印为精确到小数点后 $10$ 位的浮点数。</p><p>使用直观的方法来比较距离，并找到问题要求的 $w$ 的最小值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">double</span> <span class="hljs-title">distance</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">double</span> x1, <span class="hljs-type">long</span> <span class="hljs-type">double</span> y1, <span class="hljs-type">long</span> <span class="hljs-type">double</span> x2, <span class="hljs-type">long</span> <span class="hljs-type">double</span> y2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> t;<br>cin &gt;&gt; t;<br><br><span class="hljs-keyword">while</span> (t--) &#123;<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> px, py, ax, ay, bx, by;<br>cin &gt;&gt; px &gt;&gt; py &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;<br><br><span class="hljs-type">long</span> <span class="hljs-type">double</span> PA = <span class="hljs-built_in">distance</span>(px, py, ax, ay);<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> PB = <span class="hljs-built_in">distance</span>(px, py, bx, by);<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> OA = <span class="hljs-built_in">distance</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, ax, ay);<br><span class="hljs-type">long</span> <span class="hljs-type">double</span> OB = <span class="hljs-built_in">distance</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, bx, by);<br><br><span class="hljs-keyword">if</span> (PA &lt; PB &amp;&amp; OA &lt; OB)<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">max</span>(OA, PA) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PA &gt; PB &amp;&amp; OA &gt; OB)<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">max</span>(OB, PB) &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PA &lt; PB &amp;&amp; OA &gt; OB)<br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(OA, PA), <span class="hljs-built_in">max</span>(OB, PB)), <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(PA, OB), <span class="hljs-built_in">distance</span>(ax, ay, bx, by) / <span class="hljs-number">2.0</span>)) &lt;&lt; endl;<br><span class="hljs-keyword">else</span><br>cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(<span class="hljs-built_in">max</span>(OA, PA), <span class="hljs-built_in">max</span>(OB, PB)), <span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>(PB, OA), <span class="hljs-built_in">distance</span>(ax, ay, bx, by) / <span class="hljs-number">2.0</span>)) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>数学</tag>
      
      <tag>数学几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - SPFA的SLF优化</title>
    <link href="/2024/03/11/muban-spfa-SLFyouhua/"/>
    <url>/2024/03/11/muban-spfa-SLFyouhua/</url>
    
    <content type="html"><![CDATA[<p>SLF 优化就是 small label first 优化，由于先扩展最小的点可以尽量使程序尽早结束<br>因此当加入一个新点 u 的时候，如果此时的 dis[u] 比队首的 dis[q.front()] 小的话，就将点 v 加入队首，否则加入队尾<br>利用 STL 中的双端队列 deque 即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100010</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br><span class="hljs-type">int</span> u, v, w;<br>&#125; e[MAXN];<br><span class="hljs-type">int</span> cnt, f[MAXN], dis[MAXN], vis[MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>e[++cnt] = (Edge) &#123;<br>f[u], v, w<br>&#125;;<br>f[u] = cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>deque&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push_front</span>(s);<br>dis[s] = <span class="hljs-number">0</span>;<br>vis[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop_front</span>();<br>vis[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = f[t]; i; i = e[i].u) &#123;<br><span class="hljs-type">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span> (dis[v] &gt; dis[t] + e[i].w) &#123;<br>dis[v] = dis[t] + e[i].w;<br><span class="hljs-keyword">if</span> (!vis[v]) &#123;<br>vis[v] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; dis[v] &lt; dis[q.<span class="hljs-built_in">front</span>()] &#123;<br>q.<span class="hljs-built_in">push_front</span>(v);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>q.<span class="hljs-built_in">push_back</span>(v);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-built_in">main</span>() &#123;<br><span class="hljs-type">int</span> n, m, s, t, w;<br>cin &gt;&gt; n &gt;&gt; m;<br>cnt = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>cin &gt;&gt; s &gt;&gt; t &gt;&gt; w;<br><span class="hljs-built_in">Add</span>(s, t, w);<br>&#125;<br><span class="hljs-built_in">SPFA</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; dis[n] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
      <tag>SPFA的slf优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 矩阵快速幂</title>
    <link href="/2024/03/11/muban-juzhen-quick_pow/"/>
    <url>/2024/03/11/muban-juzhen-quick_pow/</url>
    
    <content type="html"><![CDATA[<p>矩阵快速幂&#x3D;矩阵乘法+快速幂</p><p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/bb5335de2f1843e3a03d261d14a67e37.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ll; <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> syk=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br>ll a[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>],b;<br><span class="hljs-type">int</span> n;<br>ll ans[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> ll <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//快读</span><br><span class="hljs-type">char</span> c=<span class="hljs-built_in">getchar</span>();<br>ll f=<span class="hljs-number">1</span>,x=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(c&lt;<span class="hljs-string">&#x27;0&#x27;</span>||c&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123; <br><span class="hljs-keyword">if</span>(c==<span class="hljs-string">&#x27;-&#x27;</span>)<br>f=<span class="hljs-number">-1</span>;<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">while</span>(c&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;c&lt;=<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<br>x=(x&lt;&lt;<span class="hljs-number">1</span>)+(x&lt;&lt;<span class="hljs-number">3</span>)+(c^<span class="hljs-string">&#x27;0&#x27;</span>);<br>c=<span class="hljs-built_in">getchar</span>();<br>&#125;<br><span class="hljs-keyword">return</span> x*f;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">jzcf1</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-comment">//快速幂里的第1个乘法式子子ans=ans*a</span><br>ll c[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>c[i][j]=(c[i][j]+ans[i][k]*a[k][j])%syk; <span class="hljs-comment">//mod 1e9+7</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>ans[i][j]=c[i][j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">jzcf2</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//快速幂里的第2个乘法式子子a=a*a</span><br>ll c[<span class="hljs-number">105</span>][<span class="hljs-number">105</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=n;k++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>c[i][j]=(c[i][j]+a[i][k]*a[k][j])%syk;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)&#123;<br>a[i][j]=c[i][j];<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>n=(<span class="hljs-type">int</span>)<span class="hljs-built_in">read</span>(),b=<span class="hljs-built_in">read</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>a[i][j]=<span class="hljs-built_in">read</span>();<span class="hljs-comment">//读入</span><br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>ans[i][i]=<span class="hljs-number">1</span>;  <span class="hljs-comment">//把ans初始化成单位矩阵</span><br><span class="hljs-keyword">while</span>(b)&#123;  <span class="hljs-comment">//快速幂</span><br><span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>)<br><span class="hljs-built_in">jzcf1</span>();<span class="hljs-comment">//把快速幂里的乘法改成矩阵乘法</span><br><span class="hljs-built_in">jzcf2</span>();<br>b&gt;&gt;=<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123; <span class="hljs-comment">//输出</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">register</span> <span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld &quot;</span>,ans[i][j]%syk);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>常用用法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 快速幂</title>
    <link href="/2024/03/11/muban-quick_pow/"/>
    <url>/2024/03/11/muban-quick_pow/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> b, p, k;<br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span>  <span class="hljs-title">quik_power</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> base, <span class="hljs-type">long</span> <span class="hljs-type">long</span> power,<span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span>  result = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (power &gt; <span class="hljs-number">0</span>) &#123;         <span class="hljs-comment">//指数大于0进行指数折半，底数变其平方的操作</span><br><span class="hljs-keyword">if</span> (power &amp; <span class="hljs-number">1</span>)     <span class="hljs-comment">//指数为奇数</span><br>result=result * base%k;     <span class="hljs-comment">//分离出当前项并累乘后保存</span><br>power &gt;&gt;= <span class="hljs-number">1</span>;            <span class="hljs-comment">//指数折半</span><br>base=base * base%k;           <span class="hljs-comment">//底数变其平方</span><br>&#125;<br><span class="hljs-keyword">return</span> result;              <span class="hljs-comment">//返回最终结果</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cin&gt;&gt;b&gt;&gt;p&gt;&gt;k;<br>    cout&lt;&lt;<span class="hljs-built_in">quik_power</span>(b,p,k);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>常用方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>快速幂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - Bellman-Ford</title>
    <link href="/2024/03/11/muban-Bellman-Ford/"/>
    <url>/2024/03/11/muban-Bellman-Ford/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100000</span>;<br><span class="hljs-type">int</span> n, w, m;<br><span class="hljs-type">int</span> dis[N];<br><span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-type">int</span> start;<br><span class="hljs-type">int</span> endd;<br><span class="hljs-type">int</span> value;<br>&#125; edge[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span> </span>&#123;<br>edge[k].start = u;<br>edge[k].endd = v;<br>edge[k].value = w;<br>k++;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Ford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">100000</span>, <span class="hljs-built_in">sizeof</span>(dis));<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br><span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br><span class="hljs-type">int</span> u = edge[j].start;<br><span class="hljs-type">int</span> v = edge[j].endd;<br><span class="hljs-type">int</span> w = edge[j].value;<br><span class="hljs-keyword">if</span> (dis[u] + w &lt; dis[v]) &#123;<br>flag = <span class="hljs-literal">false</span>;<br>dis[v] = dis[u] + w;<br><span class="hljs-keyword">if</span> (i == n - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (flag)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>模板</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模版 - bfs倒水问题</title>
    <link href="/2024/03/11/muban-bfs-daoshui/"/>
    <url>/2024/03/11/muban-bfs-daoshui/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> x, y, step;<br>&#125;;<br>queue&lt;node&gt; q;<br>node lu[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>], ans[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> n, m, sx, sy, ex, ey;<br><span class="hljs-type">int</span> mp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123;&#125;;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123;&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>node a = &#123;sx, sy, <span class="hljs-number">0</span>&#125;;<br>q.<span class="hljs-built_in">push</span>(a);<br>vis[sx][sy] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>() != <span class="hljs-number">1</span>) &#123;<br>node f = q.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">//cout &lt;&lt; f.x &lt;&lt; &quot; &quot; &lt;&lt; f.y &lt;&lt; &quot; &quot; &lt;&lt; f.step &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (f.x == ex &amp;&amp; f.y == ey) &#123;<br>cout &lt;&lt; f.step &lt;&lt; endl;<br>ans[f.step] = f;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = f.step - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>ans[i] = lu[ans[i + <span class="hljs-number">1</span>].x][ans[i + <span class="hljs-number">1</span>].y];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= f.step; i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; ans[i].x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; ans[i].y &lt;&lt; <span class="hljs-string">&quot;) &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nx = f.x + dx[i];<br><span class="hljs-type">int</span> ny = f.y + dy[i];<br><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m &amp;&amp; mp[nx][ny] == <span class="hljs-number">1</span> &amp;&amp; vis[nx][ny] == <span class="hljs-number">0</span>) &#123;<br>vis[nx][ny] = <span class="hljs-number">1</span>;<br>lu[nx][ny] = f;<br>node r = &#123;nx, ny, f.step + <span class="hljs-number">1</span>&#125;;<br>q.<span class="hljs-built_in">push</span>(r);<br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;no&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>cin &gt;&gt; mp[i][j];<br>&#125;<br>&#125;<br>cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;<br><span class="hljs-keyword">if</span> (mp[sx][sy] == <span class="hljs-number">2</span> || mp[ex][ey] == <span class="hljs-number">2</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">bfs</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>bfs</tag>
      
      <tag>前缀和</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - Dijkstra</title>
    <link href="/2024/03/11/muban-dijkstra/"/>
    <url>/2024/03/11/muban-dijkstra/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Dijkstra</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        dis[i] = g[st][i];<br>    &#125;<br>    vis[st] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>        <span class="hljs-type">int</span> minn = <span class="hljs-number">2147483647</span>;<br>        <span class="hljs-type">int</span> mid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; minn &gt; dis[j])&#123;<br>                minn = dis[j];<br>                mid = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>            <span class="hljs-keyword">if</span>(!vis[j] &amp;&amp; dis[j] &gt; dis[mid] + g[mid][j])&#123;<br>                dis[j] = dis[mid] + g[mid][j];<br>            &#125;<br>        &#125;<br>        vis[mid] = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆优化"><a href="#堆优化" class="headerlink" title="堆优化"></a>堆优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//Dijkstra堆优化算法模板</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> M = <span class="hljs-number">1e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> a,b,c;<br><span class="hljs-type">int</span> tot = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span><br>&#123;<br><span class="hljs-type">int</span> v,w,next;<br>&#125;edge[M];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br><span class="hljs-type">int</span> dis,idx;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Node &amp;tmp) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> tmp.dis&lt;dis;<br>&#125;<br>&#125;;<br>priority_queue &lt;Node&gt; q; <br><span class="hljs-type">int</span> dist[N],head[N];<br><span class="hljs-type">bool</span> vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> w)</span></span><br><span class="hljs-function"></span>&#123;<br>edge[++tot].v = v;<br>edge[tot].w = w;<br>edge[tot].next = head[u];<br>head[u] = tot;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())<br>&#123;<br>Node tmp = q.<span class="hljs-built_in">top</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[tmp.idx] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = head[tmp.idx];i!=<span class="hljs-number">-1</span>;i = edge[i].next)<br>&#123;<br><span class="hljs-keyword">if</span>(dist[tmp.idx]+edge[i].w &lt; dist[edge[i].v])<br>&#123;<br>dist[edge[i].v] = dist[tmp.idx]+edge[i].w;<br><span class="hljs-keyword">if</span>(!vis[edge[i].v])<br>&#123;<br>vis[edge[i].v] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(&#123;dist[edge[i].v],edge[i].v&#125;);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) head[i] = <span class="hljs-number">-1</span>,dist[i] = inf;<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);<br><span class="hljs-built_in">add</span>(a,b,c);<br>&#125;<br><span class="hljs-built_in">dijkstra</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(dist[i]==inf) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-32767 &quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dist[i]);<br>    &#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="负权图无法用迪杰斯特拉的原因"><a href="#负权图无法用迪杰斯特拉的原因" class="headerlink" title="负权图无法用迪杰斯特拉的原因"></a>负权图无法用迪杰斯特拉的原因</h3><p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/f293379d162c43eabdaeb19621830e98.png"></p>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - SPFA</title>
    <link href="/2024/03/11/muban-spfa/"/>
    <url>/2024/03/11/muban-spfa/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100010</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>&#123;<br><span class="hljs-type">int</span> u, v, w;<br>&#125;e[N];<br><span class="hljs-type">int</span> cnt, f[N], dis[N], vis[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w)</span></span>&#123;<br>e[++cnt] = &#123;f[u], v, w&#125;;<br>f[u] = cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SPFA</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>queue &lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(s);<br>dis[s] = <span class="hljs-number">0</span>;<br>vis[s] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">pop</span>();<br>vis[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = f[t]; i; i = e[i].u)&#123;<br><span class="hljs-type">int</span> v = e[i].v;<br><span class="hljs-keyword">if</span>(dis[v] &gt; dis[t] + e[i].w)&#123;<br>dis[v] = dis[t] + e[i].w;<br><span class="hljs-keyword">if</span>(!vis[v])&#123;<br>vis[v] = <span class="hljs-number">1</span>;<br>q.<span class="hljs-built_in">push</span>(v);<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> n, m, x, y, z;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br><span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(f));<br><span class="hljs-built_in">memset</span>(dis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dis));<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;<br><span class="hljs-built_in">add</span>(x, y, z);<br>&#125;<br><span class="hljs-built_in">SPFA</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; dis[n] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>图论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 最短路算法介绍</title>
    <link href="/2024/03/11/xuexibiji-zuiduanlujieshao/"/>
    <url>/2024/03/11/xuexibiji-zuiduanlujieshao/</url>
    
    <content type="html"><![CDATA[<p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/3ebb137d033144b29d659afcd879415e.png"></p><p>1、floyd算法：<br>图中一个顶点到另一个顶点的路径认为有两种，第一种是直接连接，即从起始点连接到终点，路径长度为a [ i ] [ j ]；第二种是间接连接，即通过中间点k将两者连接起来,路径长度为a [ i ] [ k ] + a [ k ] [ j ] 。而Floyd算法的任务即是比较这两种路径，选择出长度较短的路径。</p><p>2、dijkstra算法：单源最短路径<br>如题中的边带有负权值，则dijkstra算法并不适用。</p><p>3、spfa算法：<br>spfa算法与bfs算法类似。用dis数组记录源点到有向图上任意一点距离，其中源点到自身距离为0，到其他点距离为INF。将源点入队，并重复以下步骤：  </p><ol><li>队首x出队，并将该点标记为没有访问过，方便下次入队  </li><li>遍历所有以队首为起点的有向边(x,i)，更新dis[i]  </li><li>如果点i不在队列中，则i入队并标记已访问  </li><li>若队列为空，跳出循环；否则执行1</li></ol><p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/27a2be3389484550a7d0550f49623291.png"></p><h3 id="正环、零环、负环"><a href="#正环、零环、负环" class="headerlink" title="正环、零环、负环"></a>正环、零环、负环</h3><p><img src="https://api-tcoj.aicoders.cn/opt/judge/api/public/img/161dc923c7134164bdc20b450bb9e3dc.png"></p>]]></content>
    
    
    <categories>
      
      <category>最短路</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初赛 - 取值范围</title>
    <link href="/2024/03/11/knowledge-quzhi/"/>
    <url>/2024/03/11/knowledge-quzhi/</url>
    
    <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>整型：int, long long<br>浮点型: float, double<br>字符型：char<br>布尔型：bool</p><h3 id="取值范围"><a href="#取值范围" class="headerlink" title="取值范围"></a>取值范围</h3><p>unsigned int $0$ ~ $4294967295$<br>unsigned long long 的最大值：$1844674407370955161$<br>int $-2147483648$ ~ $2147483647$<br>long long：$-9223372036854775808$ ~ $9223372036854775807$ </p>]]></content>
    
    
    <categories>
      
      <category>基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>csp初赛</tag>
      
      <tag>C++基础知识</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 2n皇后</title>
    <link href="/2024/03/11/muban-2nhuanghou/"/>
    <url>/2024/03/11/muban-2nhuanghou/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> mp[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> a1[<span class="hljs-number">20</span>], b1[<span class="hljs-number">20</span>], c1[<span class="hljs-number">20</span>], d1[<span class="hljs-number">20</span>], a2[<span class="hljs-number">20</span>], b2[<span class="hljs-number">20</span>], c2[<span class="hljs-number">20</span>], d2[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(x == n + <span class="hljs-number">1</span>)&#123;<br>ans ++;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt;= n; y ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y2 = <span class="hljs-number">1</span>; y2 &lt;= n; y2 ++)&#123;<br><span class="hljs-keyword">if</span>(a1[x] == <span class="hljs-number">0</span> &amp;&amp; b1[y] == <span class="hljs-number">0</span> &amp;&amp; c1[x + y] == <span class="hljs-number">0</span> &amp;&amp; d1[x - y + n] == <span class="hljs-number">0</span> &amp;&amp; a2[x] == <span class="hljs-number">0</span> &amp;&amp; b2[y2] == <span class="hljs-number">0</span> &amp;&amp; c2[x + y2] == <span class="hljs-number">0</span> &amp;&amp; d2[x - y2 + n] == <span class="hljs-number">0</span> &amp;&amp; y != y2 &amp;&amp; mp[x][y] == <span class="hljs-number">1</span> &amp;&amp; mp[x][y2] == <span class="hljs-number">1</span>)&#123;<br>a1[x] = b1[y] = c1[x + y] = d1[x - y + n] = a2[x] = b2[y2] = c2[x + y2] = d2[x - y2 + n] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>);<br>a1[x] = b1[y] = c1[x + y] = d1[x - y + n] = a2[x] = b2[y2] = c2[x + y2] = d2[x - y2 + n] = <span class="hljs-number">0</span>;<br>&#125; <br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++)&#123;<br>cin &gt;&gt; mp[i][j];<br>&#125;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>cout &lt;&lt; ans;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>皇后问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模版 - bfs最短路径</title>
    <link href="/2024/03/11/muban-bfszuiduanlujing/"/>
    <url>/2024/03/11/muban-bfszuiduanlujing/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br><span class="hljs-type">int</span> x, y, step;<br>&#125;;<br>queue&lt;node&gt; q;<br>node lu[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>], ans[<span class="hljs-number">101</span>];<br><span class="hljs-type">int</span> n, m, sx, sy, ex, ey;<br><span class="hljs-type">int</span> mp[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123;&#125;;<br><span class="hljs-type">int</span> vis[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123;&#125;;<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span> </span>&#123;<br>node a = &#123;sx, sy, <span class="hljs-number">0</span>&#125;;<br>q.<span class="hljs-built_in">push</span>(a);<br>vis[sx][sy] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">empty</span>() != <span class="hljs-number">1</span>) &#123;<br>node f = q.<span class="hljs-built_in">front</span>();<br><span class="hljs-comment">//cout &lt;&lt; f.x &lt;&lt; &quot; &quot; &lt;&lt; f.y &lt;&lt; &quot; &quot; &lt;&lt; f.step &lt;&lt; endl;</span><br><span class="hljs-keyword">if</span> (f.x == ex &amp;&amp; f.y == ey) &#123;<br>cout &lt;&lt; f.step &lt;&lt; endl;<br>ans[f.step] = f;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = f.step - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>ans[i] = lu[ans[i + <span class="hljs-number">1</span>].x][ans[i + <span class="hljs-number">1</span>].y];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= f.step; i++) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; ans[i].x &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; ans[i].y &lt;&lt; <span class="hljs-string">&quot;) &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br><span class="hljs-type">int</span> nx = f.x + dx[i];<br><span class="hljs-type">int</span> ny = f.y + dy[i];<br><span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">1</span> &amp;&amp; nx &lt;= n &amp;&amp; ny &gt;= <span class="hljs-number">1</span> &amp;&amp; ny &lt;= m &amp;&amp; mp[nx][ny] == <span class="hljs-number">1</span> &amp;&amp; vis[nx][ny] == <span class="hljs-number">0</span>) &#123;<br>vis[nx][ny] = <span class="hljs-number">1</span>;<br>lu[nx][ny] = f;<br>node r = &#123;nx, ny, f.step + <span class="hljs-number">1</span>&#125;;<br>q.<span class="hljs-built_in">push</span>(r);<br>&#125;<br>&#125;<br>q.<span class="hljs-built_in">pop</span>();<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;no&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j++) &#123;<br>cin &gt;&gt; mp[i][j];<br>&#125;<br>&#125;<br>cin &gt;&gt; sx &gt;&gt; sy &gt;&gt; ex &gt;&gt; ey;<br><span class="hljs-keyword">if</span> (mp[sx][sy] == <span class="hljs-number">2</span> || mp[ex][ey] == <span class="hljs-number">2</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;no&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">bfs</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>最短路</tag>
      
      <tag>bfs</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - K个皇后攻击范围</title>
    <link href="/2024/03/11/muban-khuanhousj/"/>
    <url>/2024/03/11/muban-khuanhousj/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> k, n, visR[<span class="hljs-number">200</span>], visC[<span class="hljs-number">200</span>], visLD[<span class="hljs-number">200</span>], visRD[<span class="hljs-number">200</span>], ans = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++)  &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        cin &gt;&gt; x &gt;&gt; y;<br>        visR[x] = visC[y] = visLD[x - y + n] = visRD[x + y] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (visR[i] == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++) &#123;<br>            <span class="hljs-keyword">if</span>(!visC[j] &amp;&amp; !visLD[i - j + n] &amp;&amp; !visRD[i + j])&#123;<br>                ans ++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; n*n - ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dfs</tag>
      
      <tag>皇后问题</tag>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模版 - 栈、队列stl</title>
    <link href="/2024/03/11/muban-zhan-duiliestl/"/>
    <url>/2024/03/11/muban-zhan-duiliestl/</url>
    
    <content type="html"><![CDATA[<h3 id="队列STL"><a href="#队列STL" class="headerlink" title="队列STL"></a>队列STL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">queue&lt;<span class="hljs-type">int</span>&gt; q;<br>q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//进队列</span><br>q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//队首出队</span><br>q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//返回队首元素</span><br>q.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">//返回队尾元素</span><br>q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判断队列是否为空</span><br>q.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//返回队列的大小</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">deque&lt;<span class="hljs-type">int</span>&gt; dq;<br>dq.<span class="hljs-built_in">push_front</span>(x); <span class="hljs-comment">//进队</span><br>dq.<span class="hljs-built_in">pop_front</span>(); <span class="hljs-comment">//出队</span><br>dq.<span class="hljs-built_in">push_back</span>();<br>dq.<span class="hljs-built_in">pop_back</span>();<br>dq.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//判断队列是否为空</span><br>dq.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//返回队列的大小</span><br></code></pre></td></tr></table></figure><h3 id="栈STL"><a href="#栈STL" class="headerlink" title="栈STL"></a>栈STL</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">stack&lt;<span class="hljs-type">int</span>&gt; s;<br>s.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//压入元素</span><br>s.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//弹出栈顶元素</span><br>s.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//返回栈顶元素</span><br>s.<span class="hljs-built_in">empty</span>();<span class="hljs-comment">//判断栈是否为空</span><br>s.<span class="hljs-built_in">size</span>();<span class="hljs-comment">//返回栈的大小</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>队列</tag>
      
      <tag>stl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模板 - 快排</title>
    <link href="/2024/03/11/muban-kuaipai/"/>
    <url>/2024/03/11/muban-kuaipai/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qsort</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><span class="hljs-type">int</span> x = a[l], i = l, j = r;<br><span class="hljs-keyword">while</span> (i &lt; j) &#123;<br><span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[j] &gt;= x)j--;<br>a[i] = a[j];<br><span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; a[i] &lt;= x)i++;<br>a[j] = a[i];<br>&#125;<br>a[i] = x;<br>cout&lt;&lt;a[i]&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;<br><span class="hljs-built_in">qsort</span>(l, i - <span class="hljs-number">1</span>);<br><span class="hljs-built_in">qsort</span>(i + <span class="hljs-number">1</span>, r);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) cin&gt;&gt;a[i];<br><span class="hljs-built_in">qsort</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">6</span>; i++) &#123;<br>cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>模板</category>
      
      <category>常用方法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 树上常用算法</title>
    <link href="/2024/02/15/xuexibiji-tree/"/>
    <url>/2024/02/15/xuexibiji-tree/</url>
    
    <content type="html"><![CDATA[<h2 id="一、树的定义、表示"><a href="#一、树的定义、表示" class="headerlink" title="一、树的定义、表示"></a>一、树的定义、表示</h2><ul><li><p><strong>定义</strong>：连通且无环的无向图。  </p></li><li><p><strong>等价条件</strong>：</p></li></ul><p>1.$\ $连通，且含有 $n$ 个点、$n-1$ 条边。<br>2.$\ $任意两点间恰有一条路径。<br>3.$\ $无向无环的连通图。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/flgxorbk.png"></p><h3 id="1-1-1-无根树"><a href="#1-1-1-无根树" class="headerlink" title="1.1.1 无根树"></a>1.1.1 无根树</h3><ul><li>满足上述定义、没有其他限制。</li><li>每个节点的地位是相同的。</li><li>如上图。</li></ul><h3 id="1-1-2-有根树"><a href="#1-1-2-有根树" class="headerlink" title="1.1.2 有根树"></a>1.1.2 有根树</h3><ul><li>在定义的基础上、指定一个节点为“根”。</li><li>相比无根树，有根树更多地利用树的性质，组织结构更加清晰。</li><li>树上的问题一般先转化成有根树再解决。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/hkvo4g4x.png"></li></ul><h3 id="1-2-树结构的特点"><a href="#1-2-树结构的特点" class="headerlink" title="1.2 树结构的特点"></a>1.2 树结构的特点</h3><ul><li>树是具有递归结构的。</li><li>一个节点即是一棵树，若根节点为 $a$ 节点，其任意一个孩子节点 $b$，与所有不用通过 $a$ 节点即可和 $b$ 相连的节点也构成一棵树，称为以 $b$ 为根的 $a$ 的一棵子树，$b$ 的任意一棵子树也是 $a$ 的一棵子树。</li><li>如果一棵树是有根的，那么某个节点 $a$ 的深度  $d(a)&#x3D; d(father(a))+1$,其中 $father(a)$ 为 $a$ 的父亲节点，另 $d(root)&#x3D;1$。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ikxfam9a.png"></li></ul><h3 id="1-3-有根树的存储"><a href="#1-3-有根树的存储" class="headerlink" title="1.3 有根树的存储"></a>1.3 有根树的存储</h3><ul><li><p><strong>方法一</strong>：<br>除了根没有父亲，所有节点都有唯一的父亲。<br>记录每个节点的父节点即可。<br><strong>缺点</strong>：不能从根开始遍历整棵树<br><strong>应用</strong>：并查集  </p></li><li><p><strong>方法二</strong>：<br>用邻接表存储 (同普通的无向图)。<br><strong>应用</strong>：(很多 OI 题中) 只知道树边的两个端点、不知道父子关系的情况，任选一个点为根。</p></li></ul><h3 id="树的表示和存储-邻接表"><a href="#树的表示和存储-邻接表" class="headerlink" title="树的表示和存储-邻接表"></a>树的表示和存储-邻接表</h3><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/755yjrxo.png"></p><ul><li><strong>实现一</strong>：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/j5bcff8w.png"></li><li><strong>实现二</strong>：<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/zjwjfrqc.png"></li></ul><h2 id="二、树的遍历"><a href="#二、树的遍历" class="headerlink" title="二、树的遍历"></a>二、树的遍历</h2><ul><li><p><strong>深度优先 - DFS</strong><br>最常用的遍历方式，遍历一个结点后接下来遍历这个结点的第一个没有被遍历过的子节点，如果没有这样的点就退出，时间复杂度 $O(n)$。(先序、中序、后序)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/jz18ow6b.png"><br>过去：已经访问<br>现在：正在访问<br>将来：未访问</p></li><li><p><strong>广度优先 - BFS</strong><br>树上的广度优先遍历实质上是对树上的所有结点按照到根结点的距离进行分层进入队列依次处理，时间复杂度 $O(n)$。</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/swsxpmme.png"></p><h4 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h4><ul><li><a href="https://www.luogu.com.cn/problem/P1351">P1351 联合权值</a></li></ul><p><strong>思路：</strong><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/q9y75pr0.png"><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/0tiqa3ox.png"></p><ul><li>HDU2376 树上平均距离</li></ul><h3 id="三、树型动态规划"><a href="#三、树型动态规划" class="headerlink" title="三、树型动态规划"></a>三、树型动态规划</h3><ul><li>树型动态规划就是在“树形”数据结构上进行动态规划，一般的动态规划都是线性的或者是建立在图上的，线性的动态规划有二种方向既向前和向后，相应的线性的动态规划有二种方法(顺推、逆推)，而树型动态规划是建立在树上的，所以也相应的有二个方向：</li></ul><p>1.$\ $ 叶→根:即根的子节点传递有用的信息给根，之后由根得出最优解的过程。<br>2.$\ $ 根→叶:通常我们可以先任选某顶点dfs遍历一遍树，再用二次扫描换根的方式将信息传递到所有节点，过程中利用每条边来父子交换转移信息。  </p><h3 id="3-1-特点："><a href="#3-1-特点：" class="headerlink" title="3.1 特点："></a>3.1 特点：</h3><p>1.$\ $ 一般按照后序遍历的顺序，即处理完儿子再处理当前节点这符合树的子结构的性质。<br>2.$\ $ 实现方式:树形 DP 是通过记忆化搜索实现的，因此采用的是递归方式。<br>3.$\ $ 时间复杂度:树形 DP 复杂度基本上是 $O(n)$;若有附加维 $m$ 则是 $O(n*m)$</p><h3 id="3-2-动态规划算法必须满足的条件"><a href="#3-2-动态规划算法必须满足的条件" class="headerlink" title="3.2 动态规划算法必须满足的条件"></a>3.2 动态规划算法必须满足的条件</h3><p>1.$\ $ <strong>阶段性。</strong> 整个问题的求解可以划分为若干个阶段的一系列决策过程（与树的层次性相对应）。<br>2.$\ $ <strong>最优子结构性质。</strong> 一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的（与树的递归结构相对应)。<br>3.$\ $ <strong>无后效性。</strong> 将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态它以前各阶段的状态无法直接影响它未来的决策，换句话说，每个状态都是过去历史的一个完整总结（与 dfs 的时间戳特点相对应）。</p><h3 id="3-3-经典问题-树的独立集、支配集"><a href="#3-3-经典问题-树的独立集、支配集" class="headerlink" title="3.3 经典问题:树的独立集、支配集"></a>3.3 经典问题:树的独立集、支配集</h3><ul><li>对于一棵有 $N$ 个结点的无根树，选出尽量多的结点，使得任何两个结点均不相邻(称为最大独立集)。</li><li>对于最大独立集，每个点也只有两种状态,即属于点i属于独立集或者不属于独立集两种情况，通常我们可以设状态:</li></ul><p>1.$\ $ $dp[i][0]$ 表示点 $i$ 属于独立集的情况下，最大独立集中点的个数。<br>2.$\ $ $dp[i][1]$ 表示点i不属于独立集的情况下，最大独立集中点的个数。</p><h4 id="习题"><a href="#习题" class="headerlink" title="习题:"></a>习题:</h4><ul><li><a href="https://www.luogu.com.cn/problem/P1352">P1352 没有上司的舞会</a></li></ul><p><strong>思路：</strong><br>每个节点给定一个值，子节点和父亲节点不能同时选取，求能够选取的最大价值。</p><p>持续更新中。。。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 信息学竞赛中的持久化数据结构与技巧</title>
    <link href="/2024/02/08/xuexibiji-chijiuhua/"/>
    <url>/2024/02/08/xuexibiji-chijiuhua/</url>
    
    <content type="html"><![CDATA[<h2 id="1-1-信息学竞赛中的持久化数据结构与技巧"><a href="#1-1-信息学竞赛中的持久化数据结构与技巧" class="headerlink" title="1-1 信息学竞赛中的持久化数据结构与技巧"></a>1-1 信息学竞赛中的持久化数据结构与技巧</h2><hr><hr><h3 id="一、持久化（persistent）的概念"><a href="#一、持久化（persistent）的概念" class="headerlink" title="一、持久化（persistent）的概念"></a>一、持久化（persistent）的概念</h3><ul><li><strong>持久化</strong> 不是 <strong>可持久化</strong>。  </li><li>对数据结构修改后，修改前的版本仍然存在。</li></ul><h4 id="二、对数据结构的操作一般分为几类"><a href="#二、对数据结构的操作一般分为几类" class="headerlink" title="二、对数据结构的操作一般分为几类 :"></a>二、对数据结构的操作一般分为几类 :</h4><p><strong>查询</strong>: 输入一个或多个数据结构，只查询信息不做任何修改；<br><strong>修改</strong>：输入一个数据结构以及对它的修改方式，输出修改后的数据结构<br><strong>合并</strong>：输入多个数据结构，输出这几个数据结构合并后的成为的一个数据结构；</p><hr><h3 id="三、部分持久化"><a href="#三、部分持久化" class="headerlink" title="三、部分持久化"></a>三、部分持久化</h3><ul><li>数据结构的不同版本构成一个序列，其中每一个版本都可以被查询，但只有最后一个版本可以被修改。       </li><li>每次修改导致序列末尾增加一个新元素。 </li><li>这个序列称为版本序列。</li></ul><p>$e.g.$<br>原序列：$1,2,3$（第一个版本）<br>将 $2$ 修改为 $1$：$1,1,3$（第二个版本）<br>将 $3$ 修改为 $4$：$1,1,4$（第三个版本）<br>所有的版本构成一个序列，每次只能修改最后一个版本得到新的版本加入序列叫做 <strong>部分持久化</strong>。  </p><hr><h3 id="四、完全持久化"><a href="#四、完全持久化" class="headerlink" title="四、完全持久化"></a>四、完全持久化</h3><ul><li>数据结构的不同版本构成一棵有根树，每个结点是由其父亲修改得到的。  </li><li>每次可以从指定的版本中进行修改的到新的版本。</li><li>每次修改导致有根树新增一个叶子。  </li><li>这个树结构称为版本树。</li></ul><p>$e.g.$<br>原序列：$1,2,3$（第一个版本）<br>将 $2$ 修改为 $1$：$1,1,3$（第二个版本）<br>将 $3$ 修改为 $4$：$1,1,4$（第三个版本）<br>以上是一个版本序列，如果是部分持久化只能从第二个版本进行修改，而完全持久化可以从任意一个版本的基础上进行修改。<br>$e.g.$ 由第二个版本修改得第四个版本 $5,1,3$，还可由第一个版本得第五个版本 $6,2,3$ 等等。<br>那么整个从指定版本中修改得到新的版本的过程就构成了一颗版本树，如图，$1,2,3,4,5$ 代表版本编号，$1$ 是根。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/19qxydgw.png">  </p><hr><h3 id="五、可合并的持久化"><a href="#五、可合并的持久化" class="headerlink" title="五、可合并的持久化"></a>五、可合并的持久化</h3><p>数据结构的不同版本构成一个有向无环图，每个结点由其前驱 <strong>合并</strong> 或 <strong>修改</strong> 得到。对于一次合并操作，几个数据结构版本被 <strong>合并</strong> 为一个新的数据结构版本，新建的结点的前驱是被合并的结点的一次修改操作，新建的结点的前驱是被修改的一个结点，是由合并结点拼接而成的。这个图称为版本图。<br>$e.g.$<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/9ta1m0ez.png"><br>如图，版本一和版本二就合并成了版本三，版本三由版本一和版本二拼接而成，版本四也同理。  </p><hr><h3 id="六、离线处理持久化问题"><a href="#六、离线处理持久化问题" class="headerlink" title="六、离线处理持久化问题"></a>六、离线处理持久化问题</h3><ul><li>部分持久化离线后按时间升序扫版本序列，相应进行修改查询。  </li><li>完全持久化离线后对版本树进行 DFS，相应进行修改、撤销修改、查询；修改一般不能带均摊。</li></ul><hr><h3 id="七、持久化常见方法"><a href="#七、持久化常见方法" class="headerlink" title="七、持久化常见方法"></a>七、持久化常见方法</h3><h4 id="7-1-路径复制（path-copy）"><a href="#7-1-路径复制（path-copy）" class="headerlink" title="7.1. 路径复制（path copy）"></a>7.1. 路径复制（path copy）</h4><ul><li>要求数据结构按有根树存储。</li><li>每个结点有指向每个孩子的指针，没有其它指针。</li><li>修改或查询中，访问一个非根的结点必须先访问它的父亲。</li><li>修改时，如果需要修改某个结点，则复制一份再修改。</li><li>修改时，如果一个节点的孩子被修改，则这个结点也发生修改，需要将指向孩子的指针改为指向修改后的孩子的指针。  </li><li>如果需要新建结点，则直接新建。</li><li>如果需要删除结点，则只能删除不被任何指针指向的结点。</li><li>不改变原数据结构的单次修改&#x2F;查询的时间复杂度。</li><li>空间复杂度和时间复杂度相同。</li><li>对数据结构的结构有限制。</li><li>支持部分持久化、完全持久化、可合并的持久化。</li><li>对于带均摊时间复杂度的数据结构，因为同个版本可以被多次修改，可能被卡掉最坏情况。</li><li>应用：<br>1.$\ $栈（push&#x2F;pop&#x2F;top）<br>2.$\ $线段树（单点&#x2F;区间&#x2F;修改&#x2F;查询）<br>3.$\ $平衡树（单点&#x2F;区间&#x2F;修改&#x2F;查询，分裂&#x2F;合并）<br>4.$\ $可并堆</li></ul><h4 id="7-2-1-1-肥结点（fat-node）-部分持久化"><a href="#7-2-1-1-肥结点（fat-node）-部分持久化" class="headerlink" title="7.2.1.1. 肥结点（fat node）- 部分持久化"></a>7.2.1.1. 肥结点（fat node）- 部分持久化</h4><ul><li>对原数据结构的内存中的每个位置的值，维护其经历的每次修改的时刻和修改后的值。</li><li>相当于部分持久化数组。</li><li>记对值的修改次数为 $m_1$，对值的査询次数为 $m_2$。</li><li>使用带末端插入的数组，查询时二分查找，时间复杂度为 $O((m_1+m_2)\ log\ m_1)$，空间 $O(m_1)$。</li><li>若使用 vEB 树，则时间复杂度可以降低到 $O((m_1+m_2)\ log\ m_1)$。</li></ul><h4 id="7-2-1-2-补-O-log-n-O-1-的动态标号法"><a href="#7-2-1-2-补-O-log-n-O-1-的动态标号法" class="headerlink" title="7.2.1.2 补: $O(log\ n)-O(1)$ 的动态标号法"></a>7.2.1.2 补: $O(log\ n)-O(1)$ 的动态标号法</h4><ul><li>问题描述：维护双向链表，支持在给定结点前后插入，查询两个结点的先后关系。</li><li>使用重量平衡树（单点插入时只改变 $O(log\ n)$ 个结点与根的相对位置）维护节点的顺序。</li><li>在平衡树上每个结点维护一个区间，根对应 $[0,2^w-1)$。</li><li>$[l,r)$ 的左右孩子分别对应 $[1,(1+r)&#x2F;2)$，$[(1+r)&#x2F;2,r)$。</li><li>如果一个结点与根的相对位置发生改变，则重新计算结点对应的区间</li><li>每个结点对应的标号是 $(1+r)&#x2F;2$</li><li>插入结点的时间复杂度是 $O(log\ n)$</li><li>比较结点的先后关系只需 $O(1)$ 比较标号</li></ul><h4 id="7-2-2-1-肥结点（fat-node）-完全持久化"><a href="#7-2-2-1-肥结点（fat-node）-完全持久化" class="headerlink" title="7.2.2.1 肥结点（fat node）- 完全持久化"></a>7.2.2.1 肥结点（fat node）- 完全持久化</h4><ul><li>考虑版本树的括号序列，将其视为一个等效的修改序列</li><li>每次对值的修改相当于在序列中插入两次修改操作</li><li>使用 $O(log\ n)-O(1)$ 的动态标号法维护等效的修改序列中的时刻</li><li>使用平衡树维护每个值的修改序列的插入和查询</li><li>时间复杂度 $O((m_1+m_2)\ log\ m_1))$，空间 $O(m_1)$。</li><li>如何改进 （见 $7.2.2.3$）</li></ul><h4 id="7-2-2-2-补：-O-1-O-1-的小规模动态标号法"><a href="#7-2-2-2-补：-O-1-O-1-的小规模动态标号法" class="headerlink" title="7.2.2.2 补：$O(1)-O(1)$ 的小规模动态标号法"></a>7.2.2.2 补：$O(1)-O(1)$ 的小规模动态标号法</h4><ul><li>问题描述：维护双向链表，支持在给定结点前后插入，查询两个结点的先后关系；结点不超过 $w$ 个。</li><li>初始化时，给链表每个结点分配等差数列编号，且链表首尾的差充分大。</li><li>插入结点时，标号为前驱和后继的标号的平均数。</li><li>插入结点的时间复杂度是 $O(1)$。</li><li>比较结点的先后关系只需 $O(1)$ 比较标号。</li><li>可以嵌套使用，处理结点不超过 $w^{O(1)}$ 个的情况，每层结点超过 $w$ 个就分裂后重新初始化，并在上层插入一个结点。</li></ul><h4 id="7-2-2-3-肥结点（fat-node）-完全持久化-改进"><a href="#7-2-2-3-肥结点（fat-node）-完全持久化-改进" class="headerlink" title="7.2.2.3 肥结点（fat node）- 完全持久化 改进"></a>7.2.2.3 肥结点（fat node）- 完全持久化 改进</h4><ul><li>对修改序列选出一些代表元。</li><li>用 $O(log\ n)-O(1)$ 的动态标号法维护代表元的标号。</li><li>维护性质:<br>修改序列中，相邻 $log^2(m_1)$ 个位置有至少一个代表元。<br>每个值对应的修改序列中，相邻 $log^2(m_1)$ 个位置有至少一个代表元。</li><li>每次插入修改操作，均摊增加 $\frac{1}{log^2(m_1)}$ 个代表元，改变 $\frac{1}{<br>log(m_1)}$ 个代表元的标号。</li><li>修改序列中，两个代表元间的 $O(log^2(m_1))$ 个修改操作，用 $O(1)-O(1)$ 的小规模动态标号法（嵌套两层）维护动态标号。</li><li>每个值对应的修改序列中，用 vEB 树维护代表元，在标号变化时删除并重新插入;用平衡树维护两个代表元间的 $O(log^2(m_1))$ 个修改操作，在非代表元变成代表元时分裂;支持 $O(log\ log(m_1))$ 查询后继。</li><li>时间复杂度 $O((m_1+m_2)\ log\ log\ m_1)$</li></ul><h4 id="7-3-1-结点分裂（nodes-splitting）"><a href="#7-3-1-结点分裂（nodes-splitting）" class="headerlink" title="7.3.1. 结点分裂（nodes splitting）"></a>7.3.1. 结点分裂（nodes splitting）</h4><ul><li>可以将路径复制和肥结点结合，得到结点分裂方法</li><li>要求数据结构按有向图存储</li><li>如果每个结点的入度和出度分别有常数上界，则可以使用结点分裂高效实现完全持久化</li><li>每个结点维护原数据结构上结点的常数个版本</li><li>完全持久化中，单个节点的修改对应于在相应结点上插入两个版本（如果修改了指针，指针两侧的结点都要插入版本）</li><li>一个结点 $x$ 上版本过多时，分裂为两个结点 $x$ 和 $x’$，此时需要相应修改与这个节点相邻的结点（给相邻节点插入一个修改操作，把指向 $x$ 的指针改为指向 $x’$）</li><li>结点上的版本个数足够多的时，分裂导致的递归分裂均摊是少的，单次修改是 $O(1)$ 的。</li><li>另外用 $O(log\ n)-O(1)$ 的小规模动态标号法维护每个版本的的标号，得到 $O(1)-O(1)$ 的动态的标号。</li><li>应用<br>1.$\ $双端队列<br>2.$\ $维护了父指针的平衡树<br>3.$\ $并查集<br>4.$\ $自底向上的动态树的持久化</li></ul><hr><h3 id="八、持久化数据结构"><a href="#八、持久化数据结构" class="headerlink" title="八、持久化数据结构"></a>八、持久化数据结构</h3><ol><li>持久化数组</li><li>持久化线段树</li><li>持久化平衡树</li><li>持久化可并堆</li><li>持久化动态树</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习笔记 - 二分查找与答案（附归并模版、前缀和、差分）</title>
    <link href="/2024/01/31/xuexibiji-erfen/"/>
    <url>/2024/01/31/xuexibiji-erfen/</url>
    
    <content type="html"><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><ul><li><p>二分也就是二分查找，又叫折半查找。这种算法正如其名，每一次都要分一半。</p></li><li><p>二分算法可以分为二分查找和二分答案。</p></li><li><p>以在一个升序数组中查找一个数为例，每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p></li><li><p>二分查找和二分答案有什么区别？  </p><blockquote><p>二分查找：在一个已知的有序数据集上进行二分地查找<br>二分答案：答案有一个区间，在这个区间中二分，直到找到最优答案<br>二分查找侧重于查找一个元素是否存在，而二分答案则侧重于找到答案。</p></blockquote></li></ul><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>当我们要从一个序列中查找一个元素的时候，最快想到的方法就是暴力查找，但这种方法在数据量大时往往会超时，适用于元素较少的时候，一旦元素个数多起来，效率是非常低下，所以在实际中这种查找的方法是很少见的。</p><p>假设一个有序数组的长度为 $n$，查找一个数字，且这个数字在数组中，则直接暴力的最坏时间复杂度为 $O(n-1)$（最坏情况是这个数字在最后一个，那么遍历到倒数第二个的时候就已经知道最后一个是要查找的数了），而二分查找的最坏时间复杂度是 $O(log\ n)$，很显然，这种情况下，二分才是最优解。</p><p>二分查找法，是简单且效率较高的查找方法，又称折半查找法，但该方法是建立在数组有一定前提下的。</p><p>二分查找法的前提条件是：查找的序列必须是有序的（单调性），即该序列中的所有元素都是按照升序或者降序排列好的，如果数组乱序，那么比较后标记左右区间范围就是混乱的，元素与元素只间的差值虽然是随机的，但始终是在递增或递减。</p><p>数字炸弹的游戏大家应该都玩过，如果按顺序猜数，效率肯定没有从中间猜那么高，然而，二分查找与数字炸弹的逻辑几乎相同。</p><h4 id="二分查找的核心步骤："><a href="#二分查找的核心步骤：" class="headerlink" title="二分查找的核心步骤："></a>二分查找的核心步骤：</h4><ul><li><p>① 要有范围和查找值初始状态：数组的首尾各有一个标记，分别记为left和right<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bzwoiqna.png"><br>接下来就要进行二分，用变量 $mid$ 标记中间值的下标，然后可得变量 $mid$<br> 的计算公式为 $mid&#x3D;(left+right)\ &#x2F;\ 2$，而要查找的数组下标的范围是 $[left,\ right]$。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/9hkt8s01.png"></p></li><li><p>② 此时可以用 $while$ 循环来判断要查找数字的位置，则此时循环的执行条件是 $left&lt;right$，因为 $left$ 和 $right$ 在二分过程中找数字的过程中总是相互靠近，直至指向同一个位置。所以 $left&gt;&#x3D;right$ 时循环才停止，当 $left&#x3D;&#x3D;right$ 时，已经查找到了这个数字，此时这个数字的下标是 $left$。当 $left&gt;right$ 且数字未被找到时，说明这个数字不在列表中。</p></li><li><p>③ 以升序数组的二分查找为例，设这个列表为 $a$，下标范围为 $[left,\ right]$，中间值是 $m$，要查找的数是 $key$。现在要将 $a[m]$ 与要查找的数 $key$ 作比较。<br>如果 $a[m]$ 小于 $key$，说明 $key$ 在 $a[m]$ 右侧，则将数组从左向右压缩一半，把 $left$ 向右推，推到 $m$ 的右边，相当于把左边的数据都屏蔽了，因为 $key$ 不可能在左半边。<br>同理，如果 $a[m]$ 大于key，说明 $key$ 在 $a[m]$ 左侧，则将数组从右向左压缩一半，把 $right$ 向左推，推到 $m$ 的左边，$key$ 不可能在右半边。</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8nuzpqug.png"></p><h4 id="二分查找板子："><a href="#二分查找板子：" class="headerlink" title="二分查找板子："></a>二分查找板子：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = n;<br>    <span class="hljs-keyword">while</span> (l &lt; r) &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (a[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a[l] == x) <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>二分查找模板相关例题：<a href="https://www.luogu.com.cn/problem/P2249">P2249 查找</a>、<a href="https://www.luogu.com.cn/problem/P1177">P1177 排序</a>、<a href="https://www.luogu.com.cn/problem/P1226">P1226 快速幂</a>（快速幂其实就是一个二分求模的过程，思路：$t^N\ &#x3D; (t\ <em>\ t)^{N&#x2F;2}\ </em>\ (N\ %\ 2)$。<br>二分查找相关题目：<a href="https://www.luogu.com.cn/training/459454#problems">https://www.luogu.com.cn/training/459454</a> $(T1-T5)$</p><hr><h3 id="二分答案"><a href="#二分答案" class="headerlink" title="二分答案"></a>二分答案</h3><ul><li><p>解题的时候往往会考虑枚举答案然后检验枚举的值是否正确。若满足单调性，则满足使用二分法的条件，把这里的枚举换成二分，就变成了二分答案。</p></li><li><p>答案属于一个区间，当这个区间很大时，暴力肯定会超时，重要的是这个区间是对题目中的某个量有单调性的，此时，我们就会二分答案。每一次二分会做一次判断，看是否对应的那个量达到了需要的大小。<br>如何判断？根据题意写个 $check$ 函数，来检查序列中每一项是否为正确解，如果满足 $check$，就放弃右半区间（或左半区间），如果不满足，就放弃左半区间（或右半区间），一直往复，直至到最终的答案，放弃的区间是根据题意来判断的。</p></li><li><p>如何判断一个题是不是用二分答案做的呢?<br>常见描述：求…最大值的最小 、 求…最小值的最大。  </p></li><li><ol><li>求某序列最大值的最小时，我们二分答案，二分最大值判断条件满足后，尽量让答案往前来，即让 $right&#x3D;mid-1$。</li></ol></li><li><ol start="2"><li>求某序列最小值的最大时，我们二分答案，二分最小值，  判断条件满足后，尽量让答案往后走，即让 $left&#x3D;mid$。</li></ol></li></ul><h4 id="二分答案的前提："><a href="#二分答案的前提：" class="headerlink" title="二分答案的前提："></a>二分答案的前提：</h4><ul><li><p>1.答案在一个区间内；</p></li><li><p>2.直接正向做不好做，但容易判断一个答案可行不可行；</p></li><li><p>3.若有多个答案满足题意，则这些答案具有如下特点：若答案 $x$ 满足，则答案范围内小于 $x$ 或大于 $x$ 的答案均满足。</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nvabccyt.png"><br>以一次函数 $y&#x3D;kx+b$ 为例，已知 $y \le c$。要我们在区间 $[m，n]$ 内找到一个数，让其对应的 $y$ 达到要求 。</p><p>由图可知，$x$ $\in$ $[m,\ a]$ 都是满足的，因此最优解就是 $a$，所以，我们在区间 $[m，n]$ 中采用二分查找的方法，就能找到这个 $a$。</p><h4 id="二分答案板子"><a href="#二分答案板子" class="headerlink" title="二分答案板子"></a>二分答案板子</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">if</span> (cnt + a[i] &lt;= x) &#123;<br>cnt += a[i];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cnt = a[i];<br>ans++;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans &gt;= m;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>ans = mid;<br>l = mid + <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>r = mid - <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="相关练习"><a href="#相关练习" class="headerlink" title="相关练习"></a>相关练习</h4><h3 id="T1：P1571-眼红的Medusa"><a href="#T1：P1571-眼红的Medusa" class="headerlink" title="T1：P1571 眼红的Medusa"></a>T1：<a href="https://www.luogu.com.cn/problem/P1571">P1571 眼红的Medusa</a></h3><ul><li><p>直接打暴力 $20pts$ <a href="https://www.luogu.com.cn/record/145312193">R145312193</a>  </p></li><li><p>将第二个数组sort排序，用二分依次查找第一个数组中的每一个数字，找到了输出，$100pts$ <a href="https://www.luogu.com.cn/record/145313178">R145313178</a></p></li></ul><h3 id="T2：P1182-数列分段-Section-II"><a href="#T2：P1182-数列分段-Section-II" class="headerlink" title="T2：P1182 数列分段 Section II"></a>T2：<a href="https://www.luogu.com.cn/problem/P1182">P1182 数列分段 Section II</a></h3><p>答案最小可能是数列中的最大值（记为 $l$ )，最大可能是所有数的和（记为 $r$ ）。其次，我们发现，给出一个解，判定这个解是否合法即可，我们可以用枚举答案再判定的方法解决此题。</p><p>二分,二分建立在答案的基础上。答案的排布，是有一定规律的，即存在一个分界点 $mid$，使得区间 $[l,mid]$ 中的数都是非法解，$[mid,r]$ 中的数都是可行解。而 $mid$ 为所求的最小解。  </p><p>$100pts$ <a href="https://www.luogu.com.cn/record/145400899">R145400899</a></p><h3 id="T3：P2678-跳石头"><a href="#T3：P2678-跳石头" class="headerlink" title="T3：P2678 跳石头"></a>T3：<a href="https://www.luogu.com.cn/problem/P2678">P2678 跳石头</a></h3><p>$20pts$：暴力<br>$50pts$：考虑 DP，$f[i][j]$ 表示在前 $i$ 块石头移走 $j$ 块石头的最短距离<br>$60pts$：贪心，每次删除间距最小的，用堆维护<br>$100pts$：二分答案后贪心，先二分这个距离使其变为判断可行性问题，然后从前往后，一旦这个石头到上一个选的石头的距离小于这个二分的答案就把这块石头移走，最后看移的次数是否与要求的相符合。<a href="https://www.luogu.com.cn/record/145324398">R145324398</a>  </p><h3 id="★-T4：P1314-聪明的质检员"><a href="#★-T4：P1314-聪明的质检员" class="headerlink" title="$★$ T4：P1314 聪明的质检员"></a>$★$ T4：<a href="https://www.luogu.com.cn/problem/P1314">P1314 聪明的质检员</a></h3><ul><li>根据题意，$W$ 越大，矿石选的越少，$W$ 越小，矿石选的越多.所以，随着 $W$ 增大，$Y$ 值减小.所以，二分的判断条件出来了：</li></ul><p>当 $y &gt; s$ 时，需要增大 $W$ 来减小 $y$,从而让 $|y-s|$ 变小。<br>当 $y &#x3D;&#x3D; s$ 时，$|y-s|&#x3D;&#x3D;0$。<br>当 $y &lt; s$ 时，需要增大 $W$ 来减小 $y$,从而让 $|y-s|$ 变大，即可用二分答案完成。<br>最后再用前缀和套已有的公式计算。<br>$100pts$：<a href="https://www.luogu.com.cn/record/145428579">R145428579</a>，友情提示：请注意数据范围和 $maxn$ 和 $minn$ 的初始值。</p><p>二分答案相关题目：<a href="https://www.luogu.com.cn/training/459454#problems">https://www.luogu.com.cn/training/459454</a> $(T10-T20)$</p><hr><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="归并算法模版"><a href="#归并算法模版" class="headerlink" title="归并算法模版"></a>归并算法模版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> L[<span class="hljs-number">50</span>]&#123;&#125;, R[<span class="hljs-number">50</span>]&#123;&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mid - l + <span class="hljs-number">1</span>; i++)<br>&#123;<br>L[i] = x[l + i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; r - mid; j++)<br>&#123;<br>R[j] = x[mid + <span class="hljs-number">1</span> + j];<br>&#125;<br>L[mid - l + <span class="hljs-number">1</span>] = INT_MAX;<span class="hljs-comment">//从小到大排</span><br>R[r - mid] = INT_MAX;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = l; k &lt; r + <span class="hljs-number">1</span>; k++)<br>&#123;<br>x[k] = L[i] &lt; R[j] ? L[i++] : R[j++];<span class="hljs-comment">//从小到大排</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> x[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (l &lt; r)<br>&#123;<br><span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-built_in">mergeSort</span>(x, l, mid);<br><span class="hljs-built_in">mergeSort</span>(x, mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-built_in">merge</span>(x, l, mid, r);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最大字段和模版"><a href="#最大字段和模版" class="headerlink" title="最大字段和模版"></a>最大字段和模版</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxLR</span><span class="hljs-params">(<span class="hljs-type">int</span> x[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> sumL = <span class="hljs-number">0</span>, sumR = <span class="hljs-number">0</span>, maxL = <span class="hljs-number">0</span>, maxR = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid; i &gt;= l; i--)<br>&#123;<br>sumL += x[i];<br>maxL = <span class="hljs-built_in">max</span>(sumL, maxL);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mid + <span class="hljs-number">1</span>; i &lt;= r; i++)<br>&#123;<br>sumR += x[i];<br>maxR = <span class="hljs-built_in">max</span>(sumR, maxR);<br>&#125;<br><span class="hljs-keyword">return</span> maxL + maxR;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSum</span><span class="hljs-params">(<span class="hljs-type">int</span> x[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (l == r) <span class="hljs-keyword">return</span> x[l] &gt;= <span class="hljs-number">0</span> ? x[l] : <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> L = <span class="hljs-built_in">maxSum</span>(x, l, mid);<br><span class="hljs-type">int</span> R = <span class="hljs-built_in">maxSum</span>(x, mid + <span class="hljs-number">1</span>, r);<br><span class="hljs-type">int</span> LR = <span class="hljs-built_in">maxLR</span>(x, l, r);<br><span class="hljs-type">int</span> max = L &gt; R ? L : R;<br><span class="hljs-keyword">return</span> max = LR &gt; max ? LR : max;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和数组的每一项是可以通过原序列以递推的方式推出来的，递推公式就是：$S[i] &#x3D; S[  i - 1 ] + A[ i ]$。$S[  i - 1 ]$ 表示前 $i - 1$ 个元素的和，在这基础上加上 $A[ i ]$，就得到了前 $i$ 个元素的和 $S [ i ]$。</p><h3 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h3><p>利用差分可以实现对前缀和数组中的一段区间的元素均加上常数 $C$ 。例如：给定前缀和数组 $S$，$S$ 的差分数组 $A$ ，现在我们要将前缀和数组 $S$ 中 $[ l, r ]$ 区间的所有元素加上常数 $C$，用循环显然需要 $O(N)$ 的时间复杂度。但是如果我们求出来前缀和数组 $S$ 的差分数组 A，那么我们就可以在差分数组中让 $A[ l ] + C$，同时让 $A[ r + 1 ] - C$，此时的差分数组对应的前缀和数组即是目标数组。这样我们就在 $O(1)$ 的时间复杂度里面达到了想要的结果，尽管差分的空间复杂度比遍历要高。  </p><hr><h3 id="部分参考资料"><a href="#部分参考资料" class="headerlink" title="部分参考资料"></a>部分参考资料</h3><p><a href="https://blog.csdn.net/m0_73096566/article/details/129129517">https://blog.csdn.net/m0_73096566&#x2F;article&#x2F;details&#x2F;129129517</a><br><a href="https://blog.csdn.net/m0_73096566/article/details/129135098">https://blog.csdn.net/m0_73096566&#x2F;article&#x2F;details&#x2F;129135098</a><br><a href="https://blog.csdn.net/bubblecheese/article/details/129270040">https://blog.csdn.net/bubblecheese/article/details/129270040</a><br><a href="https://www.cnblogs.com/TFLS-gzr/p/11225057.html">https://www.cnblogs.com/TFLS-gzr/p/11225057.html</a><br><a href="https://img-blog.csdnimg.cn/img_convert/1f6c94195a0d777a08046f97efc444f2.png">https://img-blog.csdnimg.cn/img_convert&#x2F;1f6c94195a0d777a08046f97efc444f2.png</a><br><a href="https://blog.csdn.net/Colicsin/article/details/125447831">https://blog.csdn.net/Colicsin/article/details/125447831</a><br><a href="https://www.cnblogs.com/TFLS-gzr/p/11243629.html">https://www.cnblogs.com/TFLS-gzr/p/11243629.html</a><br><a href="https://www.luogu.com.cn/blog/thoq/solution-p1182">https://www.luogu.com.cn/blog/thoq/solution-p1182</a><br><a href="https://www.luogu.com.cn/blog/codinging/solution-p1314#">https://www.luogu.com.cn/blog/codinging/solution-p1314#</a><br><a href="https://www.luogu.com.cn/blog/user31611/solution-p2678">https://www.luogu.com.cn/blog/user31611/solution-p2678</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二分</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - NOIWC 2024</title>
    <link href="/2024/01/31/youji-noiwc2024/"/>
    <url>/2024/01/31/youji-noiwc2024/</url>
    
    <content type="html"><![CDATA[<p>农场主郭老也是非常的给力，NOI 冬令营全校就选了我一个。</p><p>由于没时间写了，所以后续可能还要很久才能更新，格式也没有调好。</p><p>为什么说我们的信息老师是农场主呢？那是因为我在今年出的高级班测试题，下面是这个外号的出自题目：<br><a href="https://www.luogu.com.cn/problem/T395541">T395541</a> &#x2F; <a href="https://www.luogu.com.cn/problem/T409040">T409040</a> &#x2F; <a href="https://www.luogu.com.cn/problem/T395546">T395546</a> &#x2F; <a href="https://www.luogu.com.cn/problem/T395547">T395547</a>。<br>主要来源是 <a href="https://www.luogu.com.cn/problem/T409040">T409040</a>。</p><p>（<del>我是成都七中初中学校高级班的社长</del>）</p><blockquote><p>家里冬令营写游记也是游记 —-舍障连拖夫斯基 (MhxMa)</p></blockquote><p>虽然还没有结束，现在这里占个位置。</p><p>农场主不给力，只报了线上营，<del>本来有资格可以去重庆的</del>。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>$28$ 日，线上没有直播</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>线上营发了讲义，看了看，感觉还行，讲的都是提高组的内容。下午看了看老祝讲的树上问题。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>后面几天都没有时间看直播（<del>去某校培训了</del>），找了个淘宝店录第二课堂的视频。建了个四川专群，交换到了第一课堂的直播。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>今天线上又没有直播，大清早的就看见群里的家长在吵架，吵得还带人生攻击，大概就是吐槽官方为什么不提供回放，我只想说，你不能上报名干嘛。。。</p><p><del>这些线上的人素质太低了</del>，明明报名时写的清清楚楚的，线上不提供回放，还在群里到处乱吐槽，转 <a href="https://www.luogu.com.cn/blog/DaYanZaiHappy/wc-xian-shang-nao-ju">https://www.luogu.com.cn/blog/DaYanZaiHappy/wc-xian-shang-nao-ju</a></p><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>kkk 整理了现在所有的游记，<del>我成为了唯一篇 NOI WC 游记（尺子姐姐的游记是 THU 和 NOI 写一起了）</del><br><img src="https://cdn.luogu.com.cn/upload/image_hosting/vg5dh4ef.png" alt="https://cdn.luogu.com.cn/upload/image_hosting/vg5dh4ef.png"><br>好多人评论我的博客，<del>有点小激动呢</del> </p><p>未完待续。。。</p>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>2024</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游记 - CSP-J2 2023 四川·绵阳</title>
    <link href="/2023/10/21/youji-cspj2/"/>
    <url>/2023/10/21/youji-cspj2/</url>
    
    <content type="html"><![CDATA[<p>今天是 10-21 日，是 CCF CSP-J&#x2F;S 复赛的日子。  </p><p>不想说初赛了，也就刚刚掐分数线，$S$ 差 $0.5$。</p><p>有点可惜，主要是没有好好复习。</p><p>我所在的省份，也就是四川，有四个考点，成都有两个，绵阳有两个。我在成都读书，但是，好巧不巧的是，我被分到了绵阳考点，意味着我在比赛前一天还要前往绵阳市。</p><p>模拟赛成绩 $7$ 次，$6$ 次第一。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>今天是学校的运动会，我参加了 $1000m$ 和 $50m*30$ 接力的比赛 ，也取得了不错的成绩（$1000$ 季军，接力第一）。当然，明天是 CSP 复赛的日子。</p><p>学校运动会因为闭幕式和迎面大接力的比赛搞了很久。导致放学时间延到了 6:40（运动会没有晚自习）。而我订的 8:12 的火车啊！！！</p><p>我飞奔回家，发现自己还有时间吃个饭。当然，对于我这种住在火车南站旁边的人，赶火车是不用慌的。但是，我订的东站的火车啊！！！</p><p>真的能被搞无语，运动会下来整个腿都在抖，一种酸痛油然而生。</p><p>我准备坐地铁去东站，还好不用换乘，地铁时间大约在 $30$ 分钟左右，跑到地铁站的时候，差点就倒在地上了，腿上完全没力（不知道为什么，放松都做到位了的），好巧不巧的是，遇到晚高峰，地铁上一班刚走。</p><p>总算赶到火车站，还有时间去买根烤肠。</p><p>上火车了，嗯。。。。怎么说呢，我的腿。。。。（车厢在最前端，有要跑）。</p><p>这里有个好玩的，没想到这辆火车的座位方向是反着的，我以为从前往后数是第二排，结果是第十七排（是的我做错位置了）。</p><p>到达绵阳、收拾好东西快十一点了，你可以看我发的犇犇。</p><p>我们订了一个离考场很近的的酒店。</p><p>很遗憾这次没有参加 $S$ 组。</p><h3 id="Day-1-AM"><a href="#Day-1-AM" class="headerlink" title="Day 1 AM."></a>Day 1 AM.</h3><p>早餐是在酒店吃的。</p><p>餐厅全是去考 CSP 的人。</p><p>我甚至还看到了穿我们学校校服的人。</p><p>吃完早餐，走到考点 $5$ 分钟，路上喝杯茶、背背模版。</p><p>到达大门口，看见东辰学校门口挂着 “CSP-J&#x2F;S 2023 复赛 四川 - 绵阳东辰考点”。（吐槽一下，那里的电子显示屏坏了一半）</p><p>到达考点时已经离开考只剩不到 $15$ 分钟了，我以为我挺近的，结果保安看到我的座位号，让我跑快点。</p><p>我一脸懵逼，这门口不就是吗？还早着呢？</p><p>等一下，这是明志楼。。。</p><p>我是弘毅楼。。。</p><p>看了看指示图，这个人都不好了。</p><p>要穿过两个操场（一圈 $1000$ 米）。</p><p>我昨天才跑了 $1000$ 啊。。。。</p><p>这对我十分的不友好。</p><p>到的时候已经在发密码了。</p><p>用时: $30$ + $35$ + $60$ + $50$</p><p>剩下的时间全在用另外的方法写 T4。</p><h3 id="Day-1-PM"><a href="#Day-1-PM" class="headerlink" title="Day 1 PM"></a>Day 1 PM</h3><p>考的感觉还挺好，小图灵 $280$。</p><p>我好像把 T3 的 freopen 注释掉了。。。。</p><p>中午吃了个绵阳米线，赶到火车站还有一小时发车。</p><p>我返程票买的商务舱，感觉还挺好。</p><p>服务挺到位的，高铁就是不一样，速度嘎嘎快。</p><p>《商务座体验卡》</p><p>只有 $40$ 分钟。</p><h1 id="The-end"><a href="#The-end" class="headerlink" title="The end"></a>The end</h1>]]></content>
    
    
    <categories>
      
      <category>游记</category>
      
      <category>2023</category>
      
    </categories>
    
    
    <tags>
      
      <tag>游记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
